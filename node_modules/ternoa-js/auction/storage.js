"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClaimableBidBalance = exports.getAuctionDeadline = exports.getAuctionData = void 0;
const util_1 = require("@polkadot/util");
const utils_1 = require("../helpers/utils");
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
/**
 * @name getAuctionData
 * @summary       Provides the data related to an auction.
 * @param nftId   The ID of the Auctioned  NFT.
 * @returns       A JSON object with the auction data.
 */
const getAuctionData = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    const data = yield (0, blockchain_1.query)(constants_1.txPallets.auction, constants_1.chainQuery.auctions, [nftId]);
    if (data.isEmpty) {
        return null;
    }
    try {
        const { creator, startBlock, endBlock, startPrice, buyItPrice, bidders, marketplaceId, isExtended } = data.toJSON();
        const startPriceAmount = (0, util_1.bnToBn)(startPrice).toString();
        const buyItPriceAmount = buyItPrice && (0, util_1.bnToBn)(buyItPrice).toString();
        const startPriceRounded = (0, utils_1.roundBalance)(startPriceAmount);
        const buyItPriceRounded = buyItPriceAmount !== null ? (0, utils_1.roundBalance)(buyItPriceAmount) : buyItPriceAmount;
        const formattedBidders = bidders.list.map((bidder) => {
            const [address, bid] = bidder;
            const amount = (0, util_1.bnToBn)(bid).toString();
            const amountRounded = (0, utils_1.roundBalance)(amount);
            return {
                bidder: address,
                amount,
                amountRounded,
            };
        });
        const auction = {
            creator,
            startBlock,
            endBlock,
            startPrice: startPriceAmount,
            startPriceRounded,
            buyItPrice: buyItPriceAmount,
            buyItPriceRounded,
            bidders: formattedBidders,
            marketplaceId,
            isExtended,
        };
        return auction;
    }
    catch (error) {
        throw new Error(`${constants_1.Errors.AUCTION_NFT_CONVERSION_ERROR}`);
    }
});
exports.getAuctionData = getAuctionData;
/**
 * @name getAuctionDeadline
 * @summary       Provides the auction ending block.
 * @param nftId   The ID of the Auctioned  NFT.
 * @returns       Number.
 */
const getAuctionDeadline = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    const data = yield (0, blockchain_1.query)(constants_1.txPallets.auction, constants_1.chainQuery.auctions, [nftId]);
    if (data.isEmpty) {
        return null;
    }
    const { endBlock } = data.toJSON();
    return endBlock;
});
exports.getAuctionDeadline = getAuctionDeadline;
/**
 * @name getClaimableBidBalance
 * @summary         Bids balance claimable after an auction ends.
 * @param address   The bidder address.
 * @returns         Number.
 */
const getClaimableBidBalance = (address) => __awaiter(void 0, void 0, void 0, function* () {
    const data = yield (0, blockchain_1.query)(constants_1.txPallets.auction, constants_1.chainQuery.claims, [address]);
    const parsedData = data.toJSON();
    const claimable = (0, util_1.bnToBn)(parsedData).toString();
    const claimableRounded = (0, utils_1.roundBalance)(claimable);
    return {
        claimable,
        claimableRounded,
    };
});
exports.getClaimableBidBalance = getClaimableBidBalance;
