"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.claim = exports.claimTx = exports.buyItNow = exports.buyItNowTx = exports.removeBid = exports.removeBidTx = exports.addBid = exports.addBidTx = exports.endAuction = exports.endAuctionTx = exports.cancelAuction = exports.cancelAuctionTx = exports.createAuction = exports.createAuctionTx = void 0;
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
const events_1 = require("../events");
/**
 * @name createAuctionTx
 * @summary               Creates an auction for an NFT.
 * @param nftId           The ID of the NFT.
 * @param marketplaceId   The ID of the marketplace where the auction will take place.
 * @param startBlock      The ID of the block at which the auction starts.
 * @param endBlock        The ID of the block at which the auction ends.
 * @param startPrice      The price at which the auction starts.
 * @param buyItPrice      The price to directly buy the NFT before the auction starts. Optional Parameter.
 * @returns               Unsigned unsubmitted Create-Auction Transaction Hash. The Hash is only valid for 5 minutes.
 */
const createAuctionTx = (nftId, marketplaceId, startBlock, endBlock, startPrice, buyItPrice = undefined) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedStartPrice = typeof startPrice === "number" ? (0, blockchain_1.numberToBalance)(startPrice) : startPrice;
    const formattedBuyItPrice = typeof buyItPrice === "number" ? (0, blockchain_1.numberToBalance)(buyItPrice) : buyItPrice;
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.auction, constants_1.txActions.createAuction, [
        nftId,
        marketplaceId,
        startBlock,
        endBlock,
        formattedStartPrice,
        formattedBuyItPrice,
    ]);
});
exports.createAuctionTx = createAuctionTx;
/**
 * @name createAuction
 * @summary               Creates an auction for an NFT.
 * @param nftId           The ID of the NFT.
 * @param marketplaceId   The ID of the marketplace where the auction will take place.
 * @param startBlock      The ID of the block at which the auction starts.
 * @param endBlock        The ID of the block at which the auction ends.
 * @param startPrice      The price at which the auction starts.
 * @param buyItPrice      The price to directly buy the NFT before the auction starts. Optional Parameter.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               AuctionCreatedEvent Blockchain event.
 */
const createAuction = (nftId, marketplaceId, startBlock, endBlock, startPrice, buyItPrice = undefined, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.createAuctionTx)(nftId, marketplaceId, startBlock, endBlock, startPrice, buyItPrice);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.AuctionCreatedEvent);
});
exports.createAuction = createAuction;
/**
 * @name cancelAuctionTx
 * @summary       Cancels an auction for an NFT. This transaction can only be submitted if the auction has not started yet.
 * @param nftId   The ID of the NFT.
 * @returns       Unsigned unsubmitted Cancel-Auction Transaction Hash. The Hash is only valid for 5 minutes.
 */
const cancelAuctionTx = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.auction, constants_1.txActions.cancelAuction, [nftId]);
});
exports.cancelAuctionTx = cancelAuctionTx;
/**
 * @name cancelAuction
 * @summary               Cancels an auction for an NFT.
 * @param nftId           The ID of the NFT.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               AuctionCancelledEvent Blockchain event.
 */
const cancelAuction = (nftId, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.cancelAuctionTx)(nftId);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.AuctionCancelledEvent);
});
exports.cancelAuction = cancelAuction;
/**
 * @name endAuctionTx
 * @summary       Ends an auction for an NFT. This transaction can only be submitted if the auction has entered the ending period.
 * @param nftId   The ID of the NFT.
 * @returns       Unsigned unsubmitted End-Auction Transaction Hash. The Hash is only valid for 5 minutes.
 */
const endAuctionTx = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.auction, constants_1.txActions.endAuction, [nftId]);
});
exports.endAuctionTx = endAuctionTx;
/**
 * @name endAuction
 * @summary               Ends an auction for an NFT
 * @param nftId           The ID of the NFT.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               AuctionCompletedEvent Blockchain event.
 */
const endAuction = (nftId, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.endAuctionTx)(nftId);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.AuctionCompletedEvent);
});
exports.endAuction = endAuction;
/**
 * @name addBidTx
 * @summary       The bidder adds a new bid offer.
 * @param nftId   The ID of the NFT.
 * @param amount  The new bid added.
 * @returns       Unsigned unsubmitted Add-Bid Transaction Hash. The Hash is only valid for 5 minutes.
 */
const addBidTx = (nftId, amount) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedAmount = typeof amount === "number" ? (0, blockchain_1.numberToBalance)(amount) : amount;
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.auction, constants_1.txActions.addBid, [nftId, formattedAmount]);
});
exports.addBidTx = addBidTx;
/**
 * @name addBid
 * @summary               The bidder adds a new bid offer.
 * @param nftId           The ID of the NFT.
 * @param amount          The new bid added.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               BidAddedEvent Blockchain event.
 */
const addBid = (nftId, amount, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.addBidTx)(nftId, amount);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.BidAddedEvent);
});
exports.addBid = addBid;
/**
 * @name removeBidTx
 * @summary       The bidder removes his bid offer.
 * @param nftId   The ID of the NFT.
 * @returns       Unsigned unsubmitted Remove-Bid Transaction Hash. The Hash is only valid for 5 minutes.
 */
const removeBidTx = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.auction, constants_1.txActions.removeBid, [nftId]);
});
exports.removeBidTx = removeBidTx;
/**
 * @name removeBid
 * @summary               The bidder removes his bid offer.
 * @param nftId           The ID of the NFT.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               BidRemovedEvent Blockchain event.
 */
const removeBid = (nftId, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.removeBidTx)(nftId);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.BidRemovedEvent);
});
exports.removeBid = removeBid;
/**
 * @name buyItNowTx
 * @summary               The NFT can be directly buy if a buyItPrice was defined and the auction has not started yet.
 * @param nftId           The ID of the NFT.
 * @param nftBuyingPrice  The NFT buying price signed.
 * @returns               Unsigned unsubmitted Buy-It-Now Transaction Hash. The Hash is only valid for 5 minutes.
 */
const buyItNowTx = (nftId, nftBuyingPrice) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedNftBuyingPrice = typeof nftBuyingPrice === "number" ? (0, blockchain_1.numberToBalance)(nftBuyingPrice) : nftBuyingPrice;
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.auction, constants_1.txActions.buyItNow, [nftId, formattedNftBuyingPrice]);
});
exports.buyItNowTx = buyItNowTx;
/**
 * @name buyItNow
 * @summary               The NFT can be directly buy if a buyItPrice was defined and the auction has not started yet.
 * @param nftId           The ID of the NFT.
 * @param nftBuyingPrice  The NFT buying price signed.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               AuctionCompletedEvent Blockchain event.
 */
const buyItNow = (nftId, nftBuyingPrice, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.buyItNowTx)(nftId, nftBuyingPrice);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.AuctionCompletedEvent);
});
exports.buyItNow = buyItNow;
/**
 * @name claimTx
 * @summary   Bidders that did not win the auction have to claim back their bids balance after an auction ends.
 * @returns   Unsigned unsubmitted Buy-It-Now Transaction Hash. The Hash is only valid for 5 minutes.
 */
const claimTx = () => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.auction, constants_1.txActions.claim);
});
exports.claimTx = claimTx;
/**
 * @name claim
 * @summary               Bidders that did not win the auction have to claim back their bids balance after an auction ends.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               BalanceClaimedEvent Blockchain event.
 */
const claim = (keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.claimTx)();
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.BalanceClaimedEvent);
});
exports.claim = claim;
