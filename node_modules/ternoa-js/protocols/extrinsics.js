"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addConsentToOnConsentProtocol = exports.addConsentToOnConsentProtocolTx = exports.resetTransmissionProtocolTimer = exports.resetTransmissionProtocolTimerTx = exports.removeTransmissionProtocol = exports.removeTransmissionProtocolTx = exports.setTransmissionProtocol = exports.setTransmissionProtocolTx = void 0;
const events_1 = require("../events");
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
/**
 * @name setTransmissionProtocolTx
 * @summary    		              Creates an unsigned unsubmittedSet-Transmission-Protocol Transaction Hash.
 * @param nftId		              The NFT Id to add transmission protocol.
 * @param recipient            	The destination account.
 * @param protocol 	            The transmission protocol to execute.
 * @param protocolCancellation 	the cancellation period of the transmission protocol.
 * @returns  		                Unsigned unsubmitted Set-Transmission-Protocol Transaction Hash. The Hash is only valid for 5 minutes.
 */
const setTransmissionProtocolTx = (nftId, recipient, protocol, protocolCancellation) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.transmissionProtocols, constants_1.txActions.setTransmissionProtocol, [
        nftId,
        recipient,
        protocol,
        protocolCancellation,
    ]);
});
exports.setTransmissionProtocolTx = setTransmissionProtocolTx;
/**
 * @name setTransmissionProtocol
 * @summary    		              Adds a transmission protocol to any type of NFT.
 * @param nftId		              The NFT Id to add transmission protocol.
 * @param recipient            	The destination account.
 * @param protocol 	            The transmission protocol to execute.
 * @param protocolCancellation 	the cancellation period of the transmission protocol.
 * @param keyring               Account that will sign the transaction.
 * @param waitUntil             Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		                ProtocolSetEvent Blockchain event.
 */
const setTransmissionProtocol = (nftId, recipient, protocol, protocolCancellation, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.setTransmissionProtocolTx)(nftId, recipient, protocol, protocolCancellation);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.ProtocolSetEvent);
});
exports.setTransmissionProtocol = setTransmissionProtocol;
/**
 * @name removeTransmissionProtocolTx
 * @summary    		               Creates an unsigned unsubmitted Remove-Transmission-Protocol Transaction Hash for a transmission protocol.
 * @param nftId		               The NFT Id to remove the transmission protocol.
 * @returns  		                 Unsigned unsubmitted Remove-Transmission-Protocol Transaction Hash. The Hash is only valid for 5 minutes.
 */
const removeTransmissionProtocolTx = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.transmissionProtocols, constants_1.txActions.removeTransmissionProtocol, [nftId]);
});
exports.removeTransmissionProtocolTx = removeTransmissionProtocolTx;
/**
 * @name removeTransmissionProtocol
 * @summary    		               Removes a transmission protocol from an NFT.
 * @param nftId		               The NFT Id to remove the transmission protocol.
 * @param keyring                Account that will sign the transaction.
 * @param waitUntil              Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		                 ProtocolRemovedEvent Blockchain event.
 */
const removeTransmissionProtocol = (nftId, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.removeTransmissionProtocolTx)(nftId);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.ProtocolRemovedEvent);
});
exports.removeTransmissionProtocol = removeTransmissionProtocol;
/**
 * @name resetTransmissionProtocolTimerTx
 * @summary    		                Creates an unsigned unsubmitted Reset-Timer Transaction Hash for an AtBlockWithReset protocol.
 * @param nftId		                The NFT Id to reset the timer for an AtBlockWithReset protocol.
 * @param blockNumber 	          The new blockNumber to execute the AtBlockWithReset protocol.
 * @returns  		                  Unsigned unsubmitted Reset-Timer Transaction Hash. The Hash is only valid for 5 minutes.
 */
const resetTransmissionProtocolTimerTx = (nftId, blockNumber) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.transmissionProtocols, constants_1.txActions.resetTimer, [nftId, blockNumber]);
});
exports.resetTransmissionProtocolTimerTx = resetTransmissionProtocolTimerTx;
/**
 * @name resetTransmissionProtocolTimer
 * @summary    		                Resets the block execution of the transmission protocol.
 * @param nftId		                The NFT Id to remove the transmission protocol.
 * @param blockNumber 	          The new blockNumber to execute the AtBlockWithReset protocol.
 * @param keyring                 Account that will sign the transaction.
 * @param waitUntil               Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		                  TimerResetEvent Blockchain event.
 */
const resetTransmissionProtocolTimer = (nftId, blockNumber, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.resetTransmissionProtocolTimerTx)(nftId, blockNumber);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.TimerResetEvent);
});
exports.resetTransmissionProtocolTimer = resetTransmissionProtocolTimer;
/**
 * @name addConsentToOnConsentProtocolTx
 * @summary    		                Creates an unsigned unsubmitted Add-Consent Transaction Hash for an OnConsent protocol.
 * @param nftId		                The NFT Id expecting consent to be added by user.
 * @returns  		                  Unsigned unsubmitted Add-Consent Transaction Hash. The Hash is only valid for 5 minutes.
 */
const addConsentToOnConsentProtocolTx = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.transmissionProtocols, constants_1.txActions.addConsent, [nftId]);
});
exports.addConsentToOnConsentProtocolTx = addConsentToOnConsentProtocolTx;
/**
 * @name addConsentToOnConsentProtocol
 * @summary    		                Adds user consent to transmit the NFT (for users specified in the account list for OnConsent protocol only)
 * @param nftId		                The NFT Id expecting consent to be added by user.
 * @param keyring                 Account that will sign the transaction.
 * @param waitUntil               Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		                  ConsentAddedEvent Blockchain event.
 */
const addConsentToOnConsentProtocol = (nftId, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.addConsentToOnConsentProtocolTx)(nftId);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.ConsentAddedEvent);
});
exports.addConsentToOnConsentProtocol = addConsentToOnConsentProtocol;
