"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatProtocolCancellation = exports.formatOnConsentAtBlockProtocol = exports.formatOnConsentProtocol = exports.formatAtBlockWithResetProtocol = exports.formatAtBlockProtocol = void 0;
const enums_1 = require("./enums");
const blockchain_1 = require("../blockchain");
/**
 * @name formatAtBlockProtocol
 * @summary                        Returns an object according to the atBlock transmission protocol format.
 * @param protocol                 The protocol (string) : "atBlock".
 * @param executionBlock           The block number to execute the atBlock transmission protocol.
 * @returns                        An object representing the atBlock transmission protocol.
 */
const formatAtBlockProtocol = (protocol, executionBlock) => {
    if (protocol !== enums_1.ProtocolAction.AtBlock)
        throw new Error("INCORRECT_PROTOCOL: expected 'atBlock'.");
    if (typeof executionBlock !== "number")
        throw new Error("MUST_BE_A_NUMBER: executionBlock must be a number.");
    return { [enums_1.ProtocolAction.AtBlock]: executionBlock };
};
exports.formatAtBlockProtocol = formatAtBlockProtocol;
/**
 * @name formatAtBlockWithResetProtocol
 * @summary                        Returns an object according to the atBlockWithReset transmission protocol format.
 * @param protocol                 The protocol (string) : "BlockWithReset".
 * @param executionBlockWithReset  The block number to execute the atBlockWithReset transmission protocol. It can be updated later by user.
 * @returns                        An object representing the atBlockWithReset transmission protocol.
 */
const formatAtBlockWithResetProtocol = (protocol, executionBlockWithReset) => {
    if (protocol !== enums_1.ProtocolAction.AtBlockWithReset)
        throw new Error("INCORRECT_PROTOCOL: expected 'atBlockWithReset'.");
    if (typeof executionBlockWithReset !== "number")
        throw new Error("MUST_BE_A_NUMBER: executionBlockWithReset must be a number.");
    return { [enums_1.ProtocolAction.AtBlockWithReset]: executionBlockWithReset };
};
exports.formatAtBlockWithResetProtocol = formatAtBlockWithResetProtocol;
/**
 * @name formatOnConsentProtocol
 * @summary                        Returns an object according to the OnConsent transmission protocol format.
 * @param protocol                 The protocol (string) : "OnConsent".
 * @param consentList              An array of account address that need to consent the protocol.
 * @param threshold                The minimum number of consent to valid the protocol execution.
 * @returns                        An object representing the onConsent transmission protocol.
 */
const formatOnConsentProtocol = (protocol, consentList, threshold) => {
    if (protocol !== enums_1.ProtocolAction.OnConsent)
        throw new Error("INCORRECT_PROTOCOL: expected 'onConsent'.");
    consentList.map((address) => {
        if (typeof address !== "string" && !(0, blockchain_1.isValidAddress)(address))
            throw new Error("MUST_BE_A_STRING: consentList must only contains only valid address.");
    });
    if (typeof threshold !== "number")
        throw new Error("MUST_BE_A_NUMBER: threshold must be a number.");
    return {
        [enums_1.ProtocolAction.OnConsent]: {
            consentList,
            threshold,
        },
    };
};
exports.formatOnConsentProtocol = formatOnConsentProtocol;
/**
 * @name formatOnConsentAtBlockProtocol
 * @summary                        Returns an object according to the onConsentAtBlock transmission protocol format.
 * @param protocol                 The protocol (string) : "onConsentAtBlock".
 * @param consentList              An array of account address that need to consent the protocol.
 * @param threshold                The minimum number of consent to valid the protocol execution.
 * @param block                    The block number before which each user consent is expected.
 * @returns                        An object representing the onConsentAtBlock transmission protocol.
 */
const formatOnConsentAtBlockProtocol = (protocol, consentList, threshold, block) => {
    if (protocol !== enums_1.ProtocolAction.OnConsentAtBlock)
        throw new Error("INCORRECT_PROTOCOL: expected 'onConsentAtBlock'.");
    consentList.map((address) => {
        if (typeof address !== "string" && !(0, blockchain_1.isValidAddress)(address))
            throw new Error("MUST_BE_A_STRING: consentList must only contains only valid address.");
    });
    if (typeof threshold !== "number" && typeof block !== "number")
        throw new Error("MUST_BE_A_NUMBER: threshold and block must be numbers.");
    return {
        [enums_1.ProtocolAction.OnConsentAtBlock]: {
            consentList,
            threshold,
            block,
        },
    };
};
exports.formatOnConsentAtBlockProtocol = formatOnConsentAtBlockProtocol;
/**
 * @name formatProtocolCancellation
 * @summary                        Returns an object according to the cancellation kind required.
 * @param cancellation             The cancellation kind (string) : "anytime", "none" or "untilBlock".
 * @param UntilBlock               The block number before which user cancellation is available. Can only be set for "untilBlock" cancellation.
 * @returns                        An object representing the cancellation of the transmission protocol.
 */
const formatProtocolCancellation = (cancellation, UntilBlock) => {
    if (cancellation !== enums_1.TransmissionCancellationAction.Anytime &&
        cancellation !== enums_1.TransmissionCancellationAction.None &&
        cancellation !== enums_1.TransmissionCancellationAction.UntilBlock)
        throw new Error("INCORRECT_CANCELLATION: cancellation must be either 'anytime', 'none' or 'untilBlock'.");
    if (UntilBlock &&
        (cancellation == enums_1.TransmissionCancellationAction.None || cancellation == enums_1.TransmissionCancellationAction.Anytime))
        throw new Error("INCORRECT_CANCELLATION: untilBlock number can't be set for 'anytime' or 'none' cancellation.");
    if (cancellation == enums_1.TransmissionCancellationAction.UntilBlock && !UntilBlock)
        throw new Error("MISSING_DATA: untilBlock cancellation must have 'UntilBlock' param define as number.");
    if (UntilBlock && typeof UntilBlock !== "number")
        throw new Error("MUST_BE_A_NUMBER: UntilBlock must be a number.");
    return cancellation === enums_1.TransmissionCancellationAction.Anytime
        ? { [enums_1.TransmissionCancellationAction.Anytime]: null }
        : cancellation === enums_1.TransmissionCancellationAction.UntilBlock && UntilBlock
            ? { [enums_1.TransmissionCancellationAction.UntilBlock]: UntilBlock }
            : { [enums_1.TransmissionCancellationAction.None]: null };
};
exports.formatProtocolCancellation = formatProtocolCancellation;
