"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRentingQueues = exports.getRentalOffers = exports.getRentalContractData = void 0;
const util_1 = require("@polkadot/util");
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
const enum_1 = require("./enum");
const utils_1 = require("../helpers/utils");
/**
 * @name getRentalContractData
 * @summary         Provides the data related to a rent contract.
 * @param nftId     The ID of the contracted NFT.
 * @returns         A JSON object with the rental contract data.
 */
const getRentalContractData = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const data = yield (0, blockchain_1.query)(constants_1.txPallets.rent, constants_1.chainQuery.contracts, [nftId]);
    if (data.isEmpty) {
        return null;
    }
    try {
        const { creationBlock, startBlock, renter, rentee, duration, acceptanceType, renterCanRevoke, rentFee, renterCancellationFee, renteeCancellationFee, } = data.toJSON();
        const creationBlockDate = yield (0, blockchain_1.blockNumberToDate)(creationBlock);
        const startBlockDate = startBlock !== null ? yield (0, blockchain_1.blockNumberToDate)(startBlock) : null;
        const isManualAcceptance = enum_1.AcceptanceAction.ManualAcceptance in acceptanceType;
        const acceptance = isManualAcceptance ? enum_1.AcceptanceAction.ManualAcceptance : enum_1.AcceptanceAction.AutoAcceptance;
        const acceptanceList = (_b = (_a = acceptanceType.manualAcceptance) !== null && _a !== void 0 ? _a : acceptanceType.autoAcceptance) !== null && _b !== void 0 ? _b : [];
        const isRentFeeToken = enum_1.RentFeeAction.Tokens in rentFee;
        const rentFeeType = isRentFeeToken ? enum_1.RentFeeAction.Tokens : enum_1.RentFeeAction.NFT;
        const rentFeeValue = isRentFeeToken ? (0, util_1.bnToBn)(rentFee.tokens).toString() : Number(rentFee.nft);
        const rentFeeValueRounded = typeof rentFeeValue === "number" ? rentFeeValue : (0, utils_1.roundBalance)(rentFeeValue);
        let renterCancellationFeeType, renterCancellationFeeValue, renterCancellationFeeValueRounded;
        switch (true) {
            case enum_1.CancellationFeeAction.FixedTokens in renterCancellationFee:
                renterCancellationFeeType = enum_1.CancellationFeeAction.FixedTokens;
                renterCancellationFeeValue = (0, util_1.bnToBn)(renterCancellationFee[renterCancellationFeeType]).toString();
                renterCancellationFeeValueRounded = (0, utils_1.roundBalance)(renterCancellationFeeValue);
                break;
            case enum_1.CancellationFeeAction.FlexibleTokens in renterCancellationFee:
                renterCancellationFeeType = enum_1.CancellationFeeAction.FlexibleTokens;
                renterCancellationFeeValue = (0, util_1.bnToBn)(renterCancellationFee[renterCancellationFeeType]).toString();
                renterCancellationFeeValueRounded = (0, utils_1.roundBalance)(renterCancellationFeeValue);
                break;
            case enum_1.CancellationFeeAction.NFT in renterCancellationFee:
                renterCancellationFeeType = enum_1.CancellationFeeAction.NFT;
                renterCancellationFeeValue = Number(renterCancellationFee[renterCancellationFeeType]);
                renterCancellationFeeValueRounded = renterCancellationFeeValue;
                break;
            default:
                renterCancellationFeeType = enum_1.CancellationFeeAction.None;
                renterCancellationFeeValue = null;
                renterCancellationFeeValueRounded = null;
                break;
        }
        let renteeCancellationFeeType, renteeCancellationFeeValue, renteeCancellationFeeValueRounded;
        switch (true) {
            case enum_1.CancellationFeeAction.FixedTokens in renteeCancellationFee:
                renteeCancellationFeeType = enum_1.CancellationFeeAction.FixedTokens;
                renteeCancellationFeeValue = (0, util_1.bnToBn)(renteeCancellationFee[renteeCancellationFeeType]).toString();
                renteeCancellationFeeValueRounded = (0, utils_1.roundBalance)(renteeCancellationFeeValue);
                break;
            case enum_1.CancellationFeeAction.FlexibleTokens in renteeCancellationFee:
                renteeCancellationFeeType = enum_1.CancellationFeeAction.FlexibleTokens;
                renteeCancellationFeeValue = (0, util_1.bnToBn)(renteeCancellationFee[renteeCancellationFeeType]).toString();
                renteeCancellationFeeValueRounded = (0, utils_1.roundBalance)(renteeCancellationFeeValue);
                break;
            case enum_1.CancellationFeeAction.NFT in renteeCancellationFee:
                renteeCancellationFeeType = enum_1.CancellationFeeAction.NFT;
                renteeCancellationFeeValue = Number(renteeCancellationFee[renteeCancellationFeeType]);
                renteeCancellationFeeValueRounded = renteeCancellationFeeValue;
                break;
            default:
                renteeCancellationFeeType = enum_1.CancellationFeeAction.None;
                renteeCancellationFeeValue = null;
                renteeCancellationFeeValueRounded = null;
                break;
        }
        return {
            creationBlock,
            creationBlockDate,
            startBlock,
            startBlockDate,
            renter,
            rentee,
            duration,
            acceptanceType: acceptance,
            acceptanceList,
            renterCanRevoke,
            rentFeeType,
            rentFee: rentFeeValue,
            rentFeeRounded: rentFeeValueRounded,
            renterCancellationFeeType,
            renterCancellationFee: renterCancellationFeeValue,
            renterCancellationFeeRounded: renterCancellationFeeValueRounded,
            renteeCancellationFeeType,
            renteeCancellationFee: renteeCancellationFeeValue,
            renteeCancellationFeeRounded: renteeCancellationFeeValueRounded,
        };
    }
    catch (error) {
        throw new Error(`${constants_1.Errors.RENT_NFT_CONVERSION_ERROR}`);
    }
});
exports.getRentalContractData = getRentalContractData;
/**
 * @name getRentalOffers
 * @summary       Provides the data related to rent contracts offers.
 * @param nftId   The ID of the contracted NFT.
 * @returns       An Array of adresse(s) (string) or null if no offer are available.
 */
const getRentalOffers = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    const data = yield (0, blockchain_1.query)(constants_1.txPallets.rent, constants_1.chainQuery.offers, [nftId]);
    const result = data.toJSON();
    return result;
});
exports.getRentalOffers = getRentalOffers;
/**
 * @name getRentingQueues
 * @summary       Provides the deadlines related to contracts in queues for available contracts, running fixed contract and running subscribed contract.
 * @returns       An object containing an array with NFT ID, the block expriation ID for each fixedQueue, subscriptionQueue or availableQueue. See the RentingQueuesType type.
 */
const getRentingQueues = () => __awaiter(void 0, void 0, void 0, function* () {
    const data = yield (0, blockchain_1.query)(constants_1.txPallets.rent, constants_1.chainQuery.queues);
    try {
        const { fixedQueue, subscriptionQueue, availableQueue } = data.toJSON();
        return {
            fixedQueue: fixedQueue.map((queue) => ({
                nftId: queue[0],
                endingBlockId: queue[1],
            })),
            subscriptionQueue: subscriptionQueue.map((queue) => ({
                nftId: queue[0],
                renewalOrEndBlockId: queue[1],
            })),
            availableQueue: availableQueue.map((queue) => ({
                nftId: queue[0],
                expirationBlockId: queue[1],
            })),
        };
    }
    catch (error) {
        throw new Error(`${constants_1.Errors.RENT_NFT_CONVERSION_ERROR}`);
    }
});
exports.getRentingQueues = getRentingQueues;
