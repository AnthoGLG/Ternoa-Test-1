"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTransformContractFee = exports.formatCancellationFee = exports.formatRentFee = exports.formatAcceptanceType = exports.formatDuration = void 0;
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
const enum_1 = require("./enum");
/**
 * @name formatDuration
 * @summary Returns an object representing a duration in either fixed or subscription format.
 *
 * @param type - The type of duration. Can be either 'fixed' or 'subscription'.
 * @param duration - The length of the contract duration in blocks.
 * @param maxDuration - (Optional) The maximum length of the contract subscription duration in blocks. Only applicable for subscriptions.
 * @param isChangeable - (Optional) A boolean indicating if the duration can be changed. Only applicable for subscriptions.
 *
 * @returns An object representing the duration of a contract.
 */
const formatDuration = (type, duration, maxDuration, isChangeable = false) => {
    if (type !== "fixed" && type !== "subscription")
        throw new Error("INCORRECT_TYPE: type has to be either 'fixed' or 'subscription'.");
    if (typeof duration !== "number")
        throw new Error("MUST_BE_A_NUMBER: duration must be a number.");
    return type === "fixed"
        ? {
            [enum_1.DurationAction.Fixed]: duration,
        }
        : {
            [enum_1.DurationAction.Subscription]: {
                [enum_1.SubscriptionActionDetails.PeriodLength]: duration,
                [enum_1.SubscriptionActionDetails.MaxDuration]: maxDuration !== null && maxDuration !== void 0 ? maxDuration : null,
                [enum_1.SubscriptionActionDetails.IsChangeable]: isChangeable,
            },
        };
};
exports.formatDuration = formatDuration;
/**
 * @name formatAcceptanceType
 * @summary Returns an object representing an acceptance type in either auto or manual format.
 *
 * @param type - The type of acceptance. Can be either 'auto' or 'manual'.
 * @param list - (Optional) A list of addresses. Only applicable for auto acceptance.
 *
 * @returns An object representing the acceptance type of a contract.
 */
const formatAcceptanceType = (type, list) => {
    if (type !== "auto" && type !== "manual")
        throw new Error("INCORRECT_TYPE: type has to be either 'auto' or 'manual'.");
    return type === "auto"
        ? {
            [enum_1.AcceptanceAction.AutoAcceptance]: list !== null && list !== void 0 ? list : null,
        }
        : {
            [enum_1.AcceptanceAction.ManualAcceptance]: list !== null && list !== void 0 ? list : null,
        };
};
exports.formatAcceptanceType = formatAcceptanceType;
/**
 * @name formatRentFee
 * @summary Returns an object representing a rent fee in either tokens or NFT format.
 *
 * @param type - The type of rent fee. Can be either 'tokens' or 'nft'.
 * @param value - The value of the rent fee. If type is 'tokens' value refers to a balance amount. If type is 'nft' value refers to the NFT id.
 *
 * @returns An object representing the rent fee of a contract.
 */
const formatRentFee = (type, value) => {
    if (type !== "tokens" && type !== "nft")
        throw new Error("INCORRECT_TYPE: type has to be either 'tokens' or 'nft'.");
    if (typeof value !== "number")
        throw new Error("MUST_BE_A_NUMBER: value must be a number.");
    return type === "tokens"
        ? {
            [enum_1.RentFeeAction.Tokens]: value,
        }
        : {
            [enum_1.RentFeeAction.NFT]: value,
        };
};
exports.formatRentFee = formatRentFee;
/**
 * @name formatCancellationFee
 * @summary Returns an object representing a cancellation fee in either fixed, flexible or NFT format.
 *
  type: "fixed" | "flexible" | "nft" | "none",
 * @param type - The type of cancellation fee. Can be either 'fixed', 'flexible', 'nft' or 'none'.
 * @param value - The value of the rent fee. If type is 'fixed' or 'flexible' value refers to a balance amount. If type is 'nft' value refers to the NFT id.
 *
 * @returns An object representing the rent fee of a contract.
 */
const formatCancellationFee = (type, value) => {
    if (type !== "fixed" && type !== "flexible" && type !== "nft" && type !== "none")
        throw new Error("INCORRECT_TYPE: type has to be either 'fixed', 'flexible', 'nft' or 'none'.");
    if (type === "none")
        return enum_1.CancellationFeeAction.None;
    if (value === undefined)
        throw new Error(`${constants_1.Errors.VALUE_MUST_BE_DEFINED}`);
    switch (type) {
        case "fixed":
            return {
                [enum_1.CancellationFeeAction.FixedTokens]: value,
            };
        case "flexible":
            return {
                [enum_1.CancellationFeeAction.FlexibleTokens]: value,
            };
        case "nft":
            return {
                [enum_1.CancellationFeeAction.NFT]: value,
            };
        default:
            return enum_1.CancellationFeeAction.None;
    }
};
exports.formatCancellationFee = formatCancellationFee;
/**
 * @name validateTransformContractFee
 * @summary         Validates the type fee and format it accordingly. Numbers are formatted into BN.
 * @param fee       The fee to format : It can only be a RentFeeType or CancellationFeeType.
 * @returns         The formatted fee.
 */
const validateTransformContractFee = (fee) => {
    if (typeof fee === "object") {
        if ("tokens" in fee && typeof fee.tokens === "number") {
            const tokensFee = (0, blockchain_1.numberToBalance)(fee.tokens);
            fee.tokens = tokensFee;
        }
        if ("fixedTokens" in fee && typeof fee.fixedTokens === "number") {
            const tokensFee = (0, blockchain_1.numberToBalance)(fee.fixedTokens);
            fee.fixedTokens = tokensFee;
        }
        if ("flexibleTokens" in fee && typeof fee.flexibleTokens === "number") {
            const tokensFee = (0, blockchain_1.numberToBalance)(fee.flexibleTokens);
            fee.flexibleTokens = tokensFee;
        }
    }
    return fee;
};
exports.validateTransformContractFee = validateTransformContractFee;
