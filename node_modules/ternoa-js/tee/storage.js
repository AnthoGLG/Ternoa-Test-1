"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNextClusterIdAvailable = exports.getEnclaveData = exports.getClusterData = void 0;
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
/**
 * @name getClusterData
 * @summary            Provides the data related to a cluster.
 * @param clusterId    The Cluster id.
 * @returns            An array containing the cluster data: the list of enclaves
 */
const getClusterData = (clusterId) => __awaiter(void 0, void 0, void 0, function* () {
    const data = yield (0, blockchain_1.query)(constants_1.txPallets.tee, constants_1.chainQuery.clusterData, [clusterId]);
    if (data.isEmpty == true) {
        throw new Error(`${constants_1.Errors.TEE_CLUSTER_NOT_FOUND}: ${clusterId}`);
    }
    try {
        const result = data.toJSON();
        return result;
    }
    catch (error) {
        throw new Error(`${constants_1.Errors.CLUSTER_CONVERSION_ERROR}`);
    }
});
exports.getClusterData = getClusterData;
/**
 * @name getEnclaveData
 * @summary            Provides the data related to an enclave.
 * @param enclaveId    The Enclave id.
 * @returns            A JSON object with the enclave data. ex:{enclaveAddress, apiUri (...)}
 */
const getEnclaveData = (enclaveId) => __awaiter(void 0, void 0, void 0, function* () {
    const data = yield (0, blockchain_1.query)(constants_1.txPallets.tee, constants_1.chainQuery.enclaveData, [enclaveId]);
    if (data.isEmpty == true) {
        throw new Error(`${constants_1.Errors.TEE_ENCLAVE_NOT_FOUND}: ${enclaveId}`);
    }
    try {
        const result = data.toJSON();
        return result;
    }
    catch (error) {
        throw new Error(`${constants_1.Errors.ENCLAVE_CONVERSION_ERROR}`);
    }
});
exports.getEnclaveData = getEnclaveData;
/**
 * @name getNextClusterIdAvailable
 * @summary            Provides the next available cluster id.
 * @returns            A number corresponding to the next available cluster id.
 */
const getNextClusterIdAvailable = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const data = yield (0, blockchain_1.query)(constants_1.txPallets.tee, constants_1.chainQuery.nextClusterId);
        if (data.isEmpty == true) {
            throw new Error(`${constants_1.Errors.NEXT_TEE_CLUSTER_UNDEFINED}`);
        }
        return data.toHuman();
    }
    catch (error) {
        throw new Error(`${constants_1.Errors.NEXT_TEE_CLUSTER_UNDEFINED}`);
    }
});
exports.getNextClusterIdAvailable = getNextClusterIdAvailable;
