"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assetTransfer = exports.assetTransferTx = void 0;
const constants_1 = require("../constants");
const blockchain_1 = require("../blockchain");
const events_1 = require("../events");
/**
 * @name assetTransferTx
 * @summary             Creates an unsigned unsubmitted Assets-Transfer Transaction Hash.
 * @param id            ID of the Asset
 * @param to            Public address of the account to transfer the amount to.
 * @param amount        Token amount to transfer.
 * @returns             Unsigned unsubmitted Assets-Transfer Transaction Hash. The Hash is only valid for 5 minutes.
 */
const assetTransferTx = (id, to, amount) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedAmount = typeof amount === "number" ? (0, blockchain_1.numberToBalance)(amount) : amount;
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.assets, constants_1.txActions.transfer, [id, to, formattedAmount]);
});
exports.assetTransferTx = assetTransferTx;
/**
 * @name assetTransfer
 * @summary             Transfers some balance to another account.
 * @param id            ID of the Asset
 * @param to            Public address of the account to transfer the amount to.
 * @param amount        Token amount to transfer.
 * @param keyring       Account that will sign the transaction.
 * @param waitUntil     Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns             AssetTransferredEvent Blockchain event.
 */
const assetTransfer = (id, to, amount, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.assetTransferTx)(id, to, amount);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.AssetTransferredEvent);
});
exports.assetTransfer = assetTransfer;
