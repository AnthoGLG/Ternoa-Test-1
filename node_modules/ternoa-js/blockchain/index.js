"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.submitTxNonBlocking = exports.submitTxBlocking = exports.numberToBalance = exports.balanceToNumber = exports.isValidSignature = exports.isValidAddress = exports.forceBatchTxHex = exports.forceBatchTx = exports.batchAllTxHex = exports.batchAllTx = exports.batchTxHex = exports.batchTx = exports.submitTxHex = exports.signTxHex = exports.createTxHex = exports.createTx = exports.checkBatchAll = exports.checkForceBatch = exports.checkBatch = exports.checkTransactionSuccess = exports.checkFundsForTxFees = exports.getTxFees = exports.getTxAdditionalFee = exports.getTxInitialFee = exports.consts = exports.query = exports.safeDisconnect = exports.getApiEndpoint = exports.isApiConnected = exports.getRawApi = exports.initializeApi = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const util_crypto_1 = require("@polkadot/util-crypto");
const api_1 = require("@polkadot/api");
const keyring_1 = require("@polkadot/keyring");
const util_1 = require("@polkadot/util");
const balance_1 = require("../balance");
const constants_1 = require("../constants");
const events_1 = require("../events");
const marketplace_1 = require("../marketplace");
const nft_1 = require("../nft");
const utils_1 = require("./utils");
const DEFAULT_CHAIN_ENDPOINT = "wss://alphanet.ternoa.com";
const TERNOA_CHAIN_DECIMALS = 18;
let api;
let chainEndpoint = DEFAULT_CHAIN_ENDPOINT;
/**
 * @name initializeApi
 * @summary       Initialize substrate api with selected or default wss endpoint.
 * @description   The default chainEndpoint is "wss://alphanet.ternoa.com"
 */
const initializeApi = (endpoint) => __awaiter(void 0, void 0, void 0, function* () {
    if (endpoint)
        chainEndpoint = endpoint;
    yield (0, util_crypto_1.cryptoWaitReady)();
    (0, exports.safeDisconnect)();
    const wsProvider = new api_1.WsProvider(chainEndpoint);
    api = yield api_1.ApiPromise.create({
        provider: wsProvider,
    });
});
exports.initializeApi = initializeApi;
/**
 * @name getRawApi
 * @summary   Get initialized substrate Api instance.
 * @returns   Raw polkadot api instance, a wrapper around the RPC and interfaces of the chain.
 */
const getRawApi = () => {
    if (!api)
        throw new Error(constants_1.Errors.API_NOT_INITIALIZED);
    if (!api.isConnected)
        throw new Error(constants_1.Errors.API_NOT_CONNECTED);
    return api;
};
exports.getRawApi = getRawApi;
/**
 * @name isApiConnected
 * @summary   Check if the Api instance existed and if it is connected.
 * @returns   Boolean, true if the underlying provider is connected, false otherwise
 */
const isApiConnected = () => {
    return Boolean(api && api.isConnected);
};
exports.isApiConnected = isApiConnected;
/**
 * @name getApiEndpoint
 * @summary   Returns the wss api endpoint
 * @returns   String, the api endpoint connected with.
 */
const getApiEndpoint = () => {
    return chainEndpoint;
};
exports.getApiEndpoint = getApiEndpoint;
/**
 * @name safeDisconnect
 * @summary   Disconnect safely from the underlying provider, halting all network traffic
 */
const safeDisconnect = () => __awaiter(void 0, void 0, void 0, function* () {
    if ((0, exports.isApiConnected)())
        yield api.disconnect();
});
exports.safeDisconnect = safeDisconnect;
/**
 * @name query
 * @summary   Generic function to make a chain query.
 * @example
 * <BR>
 *
 * ```javascript
 * // you can query without any args
 * const data = await query('balances', 'totalIssuance');
 *
 * // or you can pass args parameters to the storage query
 * const data = await query('system', 'account', ['5GesFQSwhmuMKAHcDrfm21Z5xrq6kW93C1ch2Xosq1rXx2Eh']);
 *
 * ```
 * @param module    The section required to make the chain query (eg. "system")
 * @param call      The call depending on the section (eg. "account")
 * @param args      Array of args for the call
 * @param callback  Callback function to enable subscription, if not given, no subscription will be made
 * @returns         Result of the query storage call
 */
const query = (module, call, args = [], callback) => __awaiter(void 0, void 0, void 0, function* () {
    const api = (0, exports.getRawApi)();
    if (!callback) {
        return yield api.query[module][call](...args);
    }
    else {
        return yield api.query[module][call](...args, (result) => __awaiter(void 0, void 0, void 0, function* () {
            yield callback(result);
        }));
    }
});
exports.query = query;
/**
 * @name consts
 * @summary   Generic function to get a chain constant.
 * @example
 * <BR>
 *
 * ```javascript
 * console.log(api.consts.balances.existentialDeposit.toString())
 * ```
 *
 * @param section The section required to get the chain constant (eg. "balances")
 * @param constantName The constantName depending on the section (eg. "existentialDeposit")
 * @returns The constant value
 */
const consts = (section, constantName) => {
    return (0, exports.getRawApi)().consts[section][constantName];
};
exports.consts = consts;
/**
 * @name getTxInitialFee
 * @summary         Get the weight fee estimation for a transaction.
 * @param txHex     Transaction hex
 * @param address   Public address of the sender
 * @returns         Transaction fee estimation
 */
const getTxInitialFee = (txHex, address) => __awaiter(void 0, void 0, void 0, function* () {
    const api = (0, exports.getRawApi)();
    const tx = api.tx(txHex);
    const info = yield tx.paymentInfo(address);
    return info.partialFee;
});
exports.getTxInitialFee = getTxInitialFee;
/**
 * @name getTxAdditionalFee
 * @summary       Get the fee needed by Ternoa for specific transaction services.
 * @description   Some Ternoa's services required additional fees on top of chain gas fees, for example: minting a marketplace, minting an NFT or creating a capsule.
 * @param txHex   Transaction hex
 * @returns       Fee estimation
 */
const getTxAdditionalFee = (txHex) => __awaiter(void 0, void 0, void 0, function* () {
    const api = (0, exports.getRawApi)();
    const tx = api.tx(txHex);
    switch (`${tx.method.section}_${tx.method.method}`) {
        case `${constants_1.txPallets.nft}_${constants_1.txActions.createNft}`: {
            return yield (0, nft_1.getNftMintFee)();
        }
        case `${constants_1.txPallets.marketplace}_${constants_1.txActions.create}`: {
            return yield (0, marketplace_1.getMarketplaceMintFee)();
        }
        default: {
            return new bn_js_1.default(0);
        }
    }
});
exports.getTxAdditionalFee = getTxAdditionalFee;
/**
 * @name getTxFees
 * @summary         Get the total fees for a transaction hex.
 * @param txHex     Hex of the transaction
 * @param address   Public address of the sender
 * @returns         Total estimated fee which is the sum of the chain initial fee and the optional additional fee
 */
const getTxFees = (txHex, address) => __awaiter(void 0, void 0, void 0, function* () {
    const extrinsicFee = yield (0, exports.getTxInitialFee)(txHex, address);
    const additionalFee = yield (0, exports.getTxAdditionalFee)(txHex);
    return extrinsicFee.add(additionalFee);
});
exports.getTxFees = getTxFees;
/**
 * @name checkFundsForTxFees
 * @summary   Check if a signed transaction sender has enough funds to pay transaction gas fees on transaction submit.
 * @param tx  Signed transaction object
 */
const checkFundsForTxFees = (tx) => __awaiter(void 0, void 0, void 0, function* () {
    const balance = yield (0, balance_1.getTransferrableBalance)(tx.signer.toString());
    const fees = yield (0, exports.getTxFees)(tx.toHex(), tx.signer.toString());
    if (balance.cmp(fees) === -1)
        throw new Error(constants_1.Errors.INSUFFICIENT_FUNDS);
});
exports.checkFundsForTxFees = checkFundsForTxFees;
/**
 * @name checkTransactionSuccess
 * @summary       Check if a transaction is successful.
 * @param events  Result from a submitTxBlocking function: An events list.
 * @returns       Object containing a boolean success field indicating if transaction is successful
 *                and a the list of events in case of success or the Failed Event in case of transaction failure.
 */
const checkTransactionSuccess = (events) => {
    const failedEvent = events.findEvent(events_1.ExtrinsicFailedEvent);
    if (failedEvent) {
        return {
            isTxSuccess: false,
            failedEvent,
        };
    }
    return {
        isTxSuccess: true,
        events,
    };
};
exports.checkTransactionSuccess = checkTransactionSuccess;
/**
 * @name checkBatch
 * @summary                          Check if a classic batch of transactions is successful without being interrupted. For BatchAll or ForceBatch tx, use the corresponding helper.
 * @param batchedTransactionsEvents  Result from a submitTxBlocking function triggered after a batch transaction: An events list.
 * @returns                          Object containing an isBatchInterrupted boolean, the succeeded or interrupted events and a isTxSuccess boolean to check the batch transaction status.
 */
const checkBatch = (batchedTransactionsEvents) => {
    const batchInterruptedEvent = batchedTransactionsEvents.findEvent(events_1.BatchInterruptedEvent);
    const checkTx = (0, exports.checkTransactionSuccess)(batchedTransactionsEvents);
    if (batchInterruptedEvent) {
        return {
            isBatchInterrupted: true,
            batchInterruptedEvent,
            indexInterrupted: batchInterruptedEvent.index,
            isTxSuccess: true,
        };
    }
    return Object.assign(Object.assign({}, checkTx), { isBatchInterrupted: false });
};
exports.checkBatch = checkBatch;
/**
 * @name checkForceBatch
 * @summary                          Check if a forceBatch of transactions is completed without errors. For BatchAll or Batch tx, use the corresponding helper.
 * @param batchedTransactionsEvents  Result from a submitTxBlocking function triggered after a forceBatch transaction: An events list.
 * @returns                          Object containing an isBatchCompleteWithoutErrors boolean, the succeeded or interrupted events and a isTxSuccess boolean to check the forceBatch transaction status.
 */
const checkForceBatch = (batchedTransactionsEvents) => {
    const batchIncompletedEvent = batchedTransactionsEvents.findEvent(events_1.BatchCompletedWithErrorsEvent);
    const checkTx = (0, exports.checkTransactionSuccess)(batchedTransactionsEvents);
    if (batchIncompletedEvent) {
        return {
            isBatchCompleteWithoutErrors: false,
            failedItems: batchedTransactionsEvents.findEvents(events_1.ItemFailedEvent),
            isTxSuccess: true,
        };
    }
    return Object.assign(Object.assign({}, checkTx), { isBatchCompleteWithoutErrors: true });
};
exports.checkForceBatch = checkForceBatch;
/**
 * @name checkBatchAll
 * @summary                          Check if a batchAll of transactions is succeeded or failed. For forceBatch or Batch tx, use the corresponding helper.
 * @param batchedTransactionsEvents  Result from a submitTxBlocking function triggered after a batchAll transaction: An events list.
 * @returns                          Object containing the succeeded or interrupted events and a isTxSuccess boolean to check the batchAll transaction status.
 */
const checkBatchAll = (batchedTransactionsEvents) => {
    return (0, exports.checkTransactionSuccess)(batchedTransactionsEvents);
};
exports.checkBatchAll = checkBatchAll;
/**
 * @name createTx
 * @summary             Create a transaction.
 * @param txPallet      Pallet module of the transaction
 * @param txExtrinsic   Subsequent extrinsic method of the transaction
 * @param txArgs        Arguments of the transaction
 * @returns             Transaction object unsigned
 */
const createTx = (txPallet, txExtrinsic, txArgs = []) => __awaiter(void 0, void 0, void 0, function* () { return (0, exports.getRawApi)().tx[txPallet][txExtrinsic](...txArgs); });
exports.createTx = createTx;
/**
 * @name createTxHex
 * @summary             Create a transaction in hex format.
 * @param txPallet      Pallet module of the transaction
 * @param txExtrinsic   Subsequent extrinsic method of the transaction
 * @param txArgs        Arguments of the transaction
 * @returns             Hex value of the transaction
 */
const createTxHex = (txPallet, txExtrinsic, txArgs = []) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.createTx)(txPallet, txExtrinsic, txArgs);
    return tx.toHex();
});
exports.createTxHex = createTxHex;
/**
 * @name signTxHex
 * @summary         Sign a transaction.
 * @param keyring   Keyring pair to sign the data
 * @param txHex     Tx hex of the unsigned transaction to be signed
 * @param nonce     Nonce to be used in the transaction, default to next available
 * @param validity  Number of blocks during which transaction can be submitted, default to immortal
 * @returns         Hex value of the signed transaction
 */
const signTxHex = (keyring, txHex, nonce = -1, validity = 0) => __awaiter(void 0, void 0, void 0, function* () {
    const txSigned = yield (0, exports.getRawApi)().tx(txHex).signAsync(keyring, { nonce, blockHash: api.genesisHash, era: validity });
    return txSigned.toHex();
});
exports.signTxHex = signTxHex;
/**
 * @name submitTxHex
 * @summary         Send a signed transaction on the blockchain.
 * @param txHex     Transaction hex of the signed transaction to be submitted
 * @param callback  Callback function to enable subscription, if not given, no subscription will be made
 * @returns         Hash of the transaction
 */
const submitTxHex = (txHex, callback) => __awaiter(void 0, void 0, void 0, function* () {
    const api = (0, exports.getRawApi)();
    const tx = api.tx(txHex);
    if (callback === undefined) {
        yield tx.send();
    }
    else {
        const unsub = yield tx.send((result) => __awaiter(void 0, void 0, void 0, function* () {
            try {
                yield callback(result);
                if (result.status.isFinalized) {
                    unsub();
                }
            }
            catch (err) {
                unsub();
                throw err;
            }
        }));
    }
    return tx.hash.toHex();
});
exports.submitTxHex = submitTxHex;
/**
 * @name batchTx
 * @summary         Create a batch transaction of dispatch calls.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
const batchTx = (txHexes) => __awaiter(void 0, void 0, void 0, function* () {
    const api = (0, exports.getRawApi)();
    const tx = (0, exports.createTx)(constants_1.txPallets.utility, constants_1.txActions.batch, [txHexes.map((x) => api.tx(x))]);
    return tx;
});
exports.batchTx = batchTx;
/**
 * @name batchTxHex
 * @summary         Create a batch transaction of dispatch calls in hex format.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Hex of the submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
const batchTxHex = (txHexes) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.batchTx)(txHexes);
    return tx.toHex();
});
exports.batchTxHex = batchTxHex;
/**
 * @name batchAllTx
 * @summary         Create a batchAll transaction of dispatch calls.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
const batchAllTx = (txHexes) => __awaiter(void 0, void 0, void 0, function* () {
    const api = (0, exports.getRawApi)();
    const tx = (0, exports.createTx)(constants_1.txPallets.utility, constants_1.txActions.batchAll, [txHexes.map((x) => api.tx(x))]);
    return tx;
});
exports.batchAllTx = batchAllTx;
/**
 * @name batchAllTxHex
 * @summary         Create a batchAll transaction of dispatch calls in hex format.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Hex of the submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
const batchAllTxHex = (txHexes) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.batchAllTx)(txHexes);
    return tx.toHex();
});
exports.batchAllTxHex = batchAllTxHex;
/**
 * @name forceBatchTx
 * @summary         Create a forceBatch transaction of dispatch calls.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
const forceBatchTx = (txHexes) => __awaiter(void 0, void 0, void 0, function* () {
    const api = (0, exports.getRawApi)();
    const tx = (0, exports.createTx)(constants_1.txPallets.utility, constants_1.txActions.forceBatch, [txHexes.map((x) => api.tx(x))]);
    return tx;
});
exports.forceBatchTx = forceBatchTx;
/**
 * @name forceBatchTxHex
 * @summary         Create a forceBatch transaction of dispatch calls in hex format.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Hex of the submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
const forceBatchTxHex = (txHexes) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.forceBatchTx)(txHexes);
    return tx.toHex();
});
exports.forceBatchTxHex = forceBatchTxHex;
/**
 * @name isValidAddress
 * @summary   Check if an address is a valid Ternoa address.
 * @param address
 * @returns   Boolean, true if the address is valid, false otherwise
 */
const isValidAddress = (address) => {
    try {
        (0, keyring_1.encodeAddress)((0, util_1.isHex)(address) ? (0, util_1.hexToU8a)(address) : (0, keyring_1.decodeAddress)(address));
        return true;
    }
    catch (error) {
        return false;
    }
};
exports.isValidAddress = isValidAddress;
/**
 * @name isValidSignature
 * @summary               Check if a message has been signed by the passed address.
 * @param signedMessage   Message to check.
 * @param signature
 * @param address         Address to verify the signer.
 * @returns               Boolean, true if the address signed the message, false otherwise
 */
const isValidSignature = (signedMessage, signature, address) => {
    const publicKey = (0, keyring_1.decodeAddress)(address);
    const hexPublicKey = (0, util_1.u8aToHex)(publicKey);
    return (0, util_crypto_1.signatureVerify)(signedMessage, signature, hexPublicKey).isValid;
};
exports.isValidSignature = isValidSignature;
/**
 * @name balanceToNumber
 * @summary         Format balance from BN to number.
 * @param input     BN input.
 * @param options   Formatting options from IFormatBalanceOptions.
 * @returns         Formatted balance with SI and unit notation.
 */
const balanceToNumber = (input, options) => {
    var _a;
    util_1.formatBalance.setDefaults({ decimals: 18, unit: (_a = options === null || options === void 0 ? void 0 : options.unit) !== null && _a !== void 0 ? _a : "CAPS" });
    return (0, util_1.formatBalance)(input, options);
};
exports.balanceToNumber = balanceToNumber;
/**
 * @name numberToBalance
 * @summary           Format balance from number to BN according to chain decimals.
 * @param _input      Number input
 * @param basePower   Number input
 * @returns           BN output
 */
const numberToBalance = (_input, chainDecimals = TERNOA_CHAIN_DECIMALS) => {
    if (typeof _input !== "number")
        throw new Error(`${constants_1.Errors.MUST_BE_A_NUMBER} - Amount must be a number.`);
    const input = String(_input);
    const siPower = new bn_js_1.default(chainDecimals);
    const basePower = chainDecimals;
    const siUnitPower = 0;
    const isDecimalValue = input.match(/^(\d+)\.(\d+)$/);
    let result;
    if (isDecimalValue) {
        if (siUnitPower - isDecimalValue[2].length < -basePower) {
            result = new bn_js_1.default(-1);
        }
        const div = new bn_js_1.default(input.replace(/\.\d*$/, ""));
        const modString = input.replace(/^\d+\./, "").substring(0, api.registry.chainDecimals[0] + 1);
        const mod = new bn_js_1.default(modString);
        result = div.mul(util_1.BN_TEN.pow(siPower)).add(mod.mul(util_1.BN_TEN.pow(new bn_js_1.default(basePower + siUnitPower - modString.length))));
    }
    else {
        result = new bn_js_1.default(input.replace(/[^\d]/g, "")).mul(util_1.BN_TEN.pow(siPower));
    }
    return result;
};
exports.numberToBalance = numberToBalance;
/**
 * @name submitTxBlocking
 * @summary             Signs and submits a transaction. It blocks the execution flow until the transaction is in a block or in a finalized block.
 * @param tx            Unsigned unsubmitted transaction Hash. The Hash is only valid for 5 minutes.
 * @param waitUntil     Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @param keyring       Account that will sign the transaction if provided
 * @returns             Returns a pair of objects :
 *                      - The first returned object contains some block information as the block hash, the block header and block extrinsics.
 *                      - The second returned object is an array of events which gets populated automatically once the operation is finished.
 *                      - The third returned argument is the submitted transaction hash.
 */
const submitTxBlocking = (tx, waitUntil, keyring) => __awaiter(void 0, void 0, void 0, function* () {
    const [conVar, events, blockInfo, txHash] = yield (0, exports.submitTxNonBlocking)(tx, waitUntil, keyring);
    yield conVar.wait();
    return {
        blockInfo,
        events,
        txHash,
    };
});
exports.submitTxBlocking = submitTxBlocking;
/**
 * @name submitTxNonBlocking
 * @summary             Signs and submits a transaction in a non-blocking way. Signing is optional.
 * @param tx            Unsigned unsubmitted transaction Hash. The Hash is only valid for 5 minutes.
 * @param waitUntil     Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @param keyring       Account that will sign the transaction if provided
 * @returns             Returns a group objects that are used to track the progress of the transaction execution:
 *                      - The first returned object is a conditional variable which can yield the information if the operation is finished.
 *                      - The second returned object is an array of events which gets populated automatically once the operation is finished.
 *                      - The third returned object contains the block information as the block hash, the block header and block extrinsics.
 *                      - The fouth returned argument is the submitted transaction hash.
 */
const submitTxNonBlocking = (tx, waitUntil, keyring) => __awaiter(void 0, void 0, void 0, function* () {
    const conVar = new utils_1.ConditionalVariable(500);
    const chainEvents = new events_1.BlockchainEvents([]);
    const blockInfo = new utils_1.BlockInfo();
    if (keyring) {
        tx = yield (0, exports.signTxHex)(keyring, tx);
    }
    const callback = ({ events, status }) => __awaiter(void 0, void 0, void 0, function* () {
        const isWaitingFinalization = status.isFinalized && waitUntil == constants_1.WaitUntil.BlockFinalization;
        const isWaitingInclusion = status.isInBlock && waitUntil == constants_1.WaitUntil.BlockInclusion;
        if (isWaitingInclusion || isWaitingFinalization) {
            chainEvents.inner = events.map((eventRecord) => events_1.BlockchainEvent.fromEvent(eventRecord.event));
            const blockHash = isWaitingFinalization ? status.asFinalized.toString() : status.asInBlock.toString();
            const blockData = yield api.rpc.chain.getBlock(blockHash);
            blockInfo.blockHash = blockHash;
            blockInfo.block = blockData.block;
            conVar.notify();
        }
    });
    const txHash = yield (0, exports.submitTxHex)(tx, callback);
    return [conVar, chainEvents, blockInfo, txHash];
});
exports.submitTxNonBlocking = submitTxNonBlocking;
__exportStar(require("./types"), exports);
__exportStar(require("./utils"), exports);
