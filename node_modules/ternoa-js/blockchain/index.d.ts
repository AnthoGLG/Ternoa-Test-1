import BN from "bn.js";
import { ApiPromise } from "@polkadot/api";
import { SubmittableExtrinsic } from "@polkadot/api/types";
import type { ISubmittableResult, IKeyringPair, Codec } from "@polkadot/types/types";
import type { Balance } from "@polkadot/types/interfaces/runtime";
import { WaitUntil } from "../constants";
import { BlockchainEvents } from "../events";
import { IFormatBalanceOptions, SubmitTxBlockingType, TransactionHashType, CheckTransactionType, ICheckBatch, ICheckForceBatch } from "./types";
import { BlockInfo, ConditionalVariable } from "./utils";
/**
 * @name initializeApi
 * @summary       Initialize substrate api with selected or default wss endpoint.
 * @description   The default chainEndpoint is "wss://alphanet.ternoa.com"
 */
export declare const initializeApi: (endpoint?: string) => Promise<void>;
/**
 * @name getRawApi
 * @summary   Get initialized substrate Api instance.
 * @returns   Raw polkadot api instance, a wrapper around the RPC and interfaces of the chain.
 */
export declare const getRawApi: () => ApiPromise;
/**
 * @name isApiConnected
 * @summary   Check if the Api instance existed and if it is connected.
 * @returns   Boolean, true if the underlying provider is connected, false otherwise
 */
export declare const isApiConnected: () => boolean;
/**
 * @name getApiEndpoint
 * @summary   Returns the wss api endpoint
 * @returns   String, the api endpoint connected with.
 */
export declare const getApiEndpoint: () => string;
/**
 * @name safeDisconnect
 * @summary   Disconnect safely from the underlying provider, halting all network traffic
 */
export declare const safeDisconnect: () => Promise<void>;
/**
 * @name query
 * @summary   Generic function to make a chain query.
 * @example
 * <BR>
 *
 * ```javascript
 * // you can query without any args
 * const data = await query('balances', 'totalIssuance');
 *
 * // or you can pass args parameters to the storage query
 * const data = await query('system', 'account', ['5GesFQSwhmuMKAHcDrfm21Z5xrq6kW93C1ch2Xosq1rXx2Eh']);
 *
 * ```
 * @param module    The section required to make the chain query (eg. "system")
 * @param call      The call depending on the section (eg. "account")
 * @param args      Array of args for the call
 * @param callback  Callback function to enable subscription, if not given, no subscription will be made
 * @returns         Result of the query storage call
 */
export declare const query: (module: string, call: string, args?: any[], callback?: ((result: any) => void) | undefined) => Promise<Codec>;
/**
 * @name consts
 * @summary   Generic function to get a chain constant.
 * @example
 * <BR>
 *
 * ```javascript
 * console.log(api.consts.balances.existentialDeposit.toString())
 * ```
 *
 * @param section The section required to get the chain constant (eg. "balances")
 * @param constantName The constantName depending on the section (eg. "existentialDeposit")
 * @returns The constant value
 */
export declare const consts: (section: string, constantName: string) => Codec;
/**
 * @name getTxInitialFee
 * @summary         Get the weight fee estimation for a transaction.
 * @param txHex     Transaction hex
 * @param address   Public address of the sender
 * @returns         Transaction fee estimation
 */
export declare const getTxInitialFee: (txHex: TransactionHashType, address: string) => Promise<Balance>;
/**
 * @name getTxAdditionalFee
 * @summary       Get the fee needed by Ternoa for specific transaction services.
 * @description   Some Ternoa's services required additional fees on top of chain gas fees, for example: minting a marketplace, minting an NFT or creating a capsule.
 * @param txHex   Transaction hex
 * @returns       Fee estimation
 */
export declare const getTxAdditionalFee: (txHex: TransactionHashType) => Promise<BN>;
/**
 * @name getTxFees
 * @summary         Get the total fees for a transaction hex.
 * @param txHex     Hex of the transaction
 * @param address   Public address of the sender
 * @returns         Total estimated fee which is the sum of the chain initial fee and the optional additional fee
 */
export declare const getTxFees: (txHex: TransactionHashType, address: string) => Promise<BN>;
/**
 * @name checkFundsForTxFees
 * @summary   Check if a signed transaction sender has enough funds to pay transaction gas fees on transaction submit.
 * @param tx  Signed transaction object
 */
export declare const checkFundsForTxFees: (tx: SubmittableExtrinsic<"promise", ISubmittableResult>) => Promise<void>;
/**
 * @name checkTransactionSuccess
 * @summary       Check if a transaction is successful.
 * @param events  Result from a submitTxBlocking function: An events list.
 * @returns       Object containing a boolean success field indicating if transaction is successful
 *                and a the list of events in case of success or the Failed Event in case of transaction failure.
 */
export declare const checkTransactionSuccess: (events: BlockchainEvents) => CheckTransactionType;
/**
 * @name checkBatch
 * @summary                          Check if a classic batch of transactions is successful without being interrupted. For BatchAll or ForceBatch tx, use the corresponding helper.
 * @param batchedTransactionsEvents  Result from a submitTxBlocking function triggered after a batch transaction: An events list.
 * @returns                          Object containing an isBatchInterrupted boolean, the succeeded or interrupted events and a isTxSuccess boolean to check the batch transaction status.
 */
export declare const checkBatch: (batchedTransactionsEvents: BlockchainEvents) => ICheckBatch;
/**
 * @name checkForceBatch
 * @summary                          Check if a forceBatch of transactions is completed without errors. For BatchAll or Batch tx, use the corresponding helper.
 * @param batchedTransactionsEvents  Result from a submitTxBlocking function triggered after a forceBatch transaction: An events list.
 * @returns                          Object containing an isBatchCompleteWithoutErrors boolean, the succeeded or interrupted events and a isTxSuccess boolean to check the forceBatch transaction status.
 */
export declare const checkForceBatch: (batchedTransactionsEvents: BlockchainEvents) => ICheckForceBatch;
/**
 * @name checkBatchAll
 * @summary                          Check if a batchAll of transactions is succeeded or failed. For forceBatch or Batch tx, use the corresponding helper.
 * @param batchedTransactionsEvents  Result from a submitTxBlocking function triggered after a batchAll transaction: An events list.
 * @returns                          Object containing the succeeded or interrupted events and a isTxSuccess boolean to check the batchAll transaction status.
 */
export declare const checkBatchAll: (batchedTransactionsEvents: BlockchainEvents) => CheckTransactionType;
/**
 * @name createTx
 * @summary             Create a transaction.
 * @param txPallet      Pallet module of the transaction
 * @param txExtrinsic   Subsequent extrinsic method of the transaction
 * @param txArgs        Arguments of the transaction
 * @returns             Transaction object unsigned
 */
export declare const createTx: (txPallet: string, txExtrinsic: string, txArgs?: any[]) => Promise<SubmittableExtrinsic<"promise", ISubmittableResult>>;
/**
 * @name createTxHex
 * @summary             Create a transaction in hex format.
 * @param txPallet      Pallet module of the transaction
 * @param txExtrinsic   Subsequent extrinsic method of the transaction
 * @param txArgs        Arguments of the transaction
 * @returns             Hex value of the transaction
 */
export declare const createTxHex: (txPallet: string, txExtrinsic: string, txArgs?: any[]) => Promise<TransactionHashType>;
/**
 * @name signTxHex
 * @summary         Sign a transaction.
 * @param keyring   Keyring pair to sign the data
 * @param txHex     Tx hex of the unsigned transaction to be signed
 * @param nonce     Nonce to be used in the transaction, default to next available
 * @param validity  Number of blocks during which transaction can be submitted, default to immortal
 * @returns         Hex value of the signed transaction
 */
export declare const signTxHex: (keyring: IKeyringPair, txHex: TransactionHashType, nonce?: number, validity?: number) => Promise<TransactionHashType>;
/**
 * @name submitTxHex
 * @summary         Send a signed transaction on the blockchain.
 * @param txHex     Transaction hex of the signed transaction to be submitted
 * @param callback  Callback function to enable subscription, if not given, no subscription will be made
 * @returns         Hash of the transaction
 */
export declare const submitTxHex: (txHex: TransactionHashType, callback?: ((result: ISubmittableResult) => void) | undefined) => Promise<TransactionHashType>;
/**
 * @name batchTx
 * @summary         Create a batch transaction of dispatch calls.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
export declare const batchTx: (txHexes: TransactionHashType[]) => Promise<SubmittableExtrinsic<"promise", ISubmittableResult>>;
/**
 * @name batchTxHex
 * @summary         Create a batch transaction of dispatch calls in hex format.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Hex of the submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
export declare const batchTxHex: (txHexes: TransactionHashType[]) => Promise<TransactionHashType>;
/**
 * @name batchAllTx
 * @summary         Create a batchAll transaction of dispatch calls.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
export declare const batchAllTx: (txHexes: TransactionHashType[]) => Promise<SubmittableExtrinsic<"promise", ISubmittableResult>>;
/**
 * @name batchAllTxHex
 * @summary         Create a batchAll transaction of dispatch calls in hex format.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Hex of the submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
export declare const batchAllTxHex: (txHexes: TransactionHashType[]) => Promise<TransactionHashType>;
/**
 * @name forceBatchTx
 * @summary         Create a forceBatch transaction of dispatch calls.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
export declare const forceBatchTx: (txHexes: TransactionHashType[]) => Promise<SubmittableExtrinsic<"promise", ISubmittableResult>>;
/**
 * @name forceBatchTxHex
 * @summary         Create a forceBatch transaction of dispatch calls in hex format.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Hex of the submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
export declare const forceBatchTxHex: (txHexes: TransactionHashType[]) => Promise<TransactionHashType>;
/**
 * @name isValidAddress
 * @summary   Check if an address is a valid Ternoa address.
 * @param address
 * @returns   Boolean, true if the address is valid, false otherwise
 */
export declare const isValidAddress: (address: string) => boolean;
/**
 * @name isValidSignature
 * @summary               Check if a message has been signed by the passed address.
 * @param signedMessage   Message to check.
 * @param signature
 * @param address         Address to verify the signer.
 * @returns               Boolean, true if the address signed the message, false otherwise
 */
export declare const isValidSignature: (signedMessage: string, signature: TransactionHashType, address: string) => boolean;
/**
 * @name balanceToNumber
 * @summary         Format balance from BN to number.
 * @param input     BN input.
 * @param options   Formatting options from IFormatBalanceOptions.
 * @returns         Formatted balance with SI and unit notation.
 */
export declare const balanceToNumber: (input: BN, options?: IFormatBalanceOptions) => string;
/**
 * @name numberToBalance
 * @summary           Format balance from number to BN according to chain decimals.
 * @param _input      Number input
 * @param basePower   Number input
 * @returns           BN output
 */
export declare const numberToBalance: (_input: number, chainDecimals?: number) => BN;
/**
 * @name submitTxBlocking
 * @summary             Signs and submits a transaction. It blocks the execution flow until the transaction is in a block or in a finalized block.
 * @param tx            Unsigned unsubmitted transaction Hash. The Hash is only valid for 5 minutes.
 * @param waitUntil     Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @param keyring       Account that will sign the transaction if provided
 * @returns             Returns a pair of objects :
 *                      - The first returned object contains some block information as the block hash, the block header and block extrinsics.
 *                      - The second returned object is an array of events which gets populated automatically once the operation is finished.
 *                      - The third returned argument is the submitted transaction hash.
 */
export declare const submitTxBlocking: (tx: TransactionHashType, waitUntil: WaitUntil, keyring?: IKeyringPair) => Promise<SubmitTxBlockingType>;
/**
 * @name submitTxNonBlocking
 * @summary             Signs and submits a transaction in a non-blocking way. Signing is optional.
 * @param tx            Unsigned unsubmitted transaction Hash. The Hash is only valid for 5 minutes.
 * @param waitUntil     Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @param keyring       Account that will sign the transaction if provided
 * @returns             Returns a group objects that are used to track the progress of the transaction execution:
 *                      - The first returned object is a conditional variable which can yield the information if the operation is finished.
 *                      - The second returned object is an array of events which gets populated automatically once the operation is finished.
 *                      - The third returned object contains the block information as the block hash, the block header and block extrinsics.
 *                      - The fouth returned argument is the submitted transaction hash.
 */
export declare const submitTxNonBlocking: (tx: TransactionHashType, waitUntil: WaitUntil, keyring?: IKeyringPair) => Promise<[ConditionalVariable, BlockchainEvents, BlockInfo, `0x${string}`]>;
export * from "./types";
export * from "./utils";
