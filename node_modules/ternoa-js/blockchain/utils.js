"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.blockNumberToDate = exports.BlockInfo = exports.ConditionalVariable = exports.sleep = void 0;
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.sleep = sleep;
class ConditionalVariable {
    constructor(sleepInterval = 500, maxWaitTime) {
        this.done = false;
        this.maxWaitTime = maxWaitTime;
        this.sleepInterval = sleepInterval;
    }
    notify() {
        this.done = true;
    }
    wait() {
        return __awaiter(this, void 0, void 0, function* () {
            let sum = 0;
            while (this.done === false) {
                if (this.maxWaitTime && sum >= this.maxWaitTime) {
                    return false;
                }
                yield sleep(this.sleepInterval);
                sum += this.sleepInterval;
            }
            return true;
        });
    }
    isDone() {
        return this.done;
    }
    clear() {
        this.done = false;
    }
}
exports.ConditionalVariable = ConditionalVariable;
class BlockInfo {
    constructor(block, blockHash) {
        this.block = block;
        this.blockHash = blockHash;
    }
}
exports.BlockInfo = BlockInfo;
const blockNumberToDate = (blockNumber) => __awaiter(void 0, void 0, void 0, function* () {
    if (blockNumber <= 0)
        throw new Error(constants_1.Errors.VALUE_MUST_BE_GREATER_THAN_0);
    const api = (0, blockchain_1.getRawApi)();
    const lastBlockDatas = yield api.rpc.chain.getBlock();
    const lastBlockNumber = Number(lastBlockDatas.block.header.number.toString());
    if (blockNumber > lastBlockNumber)
        throw new Error(constants_1.Errors.BLOCK_NOT_FOUND_ON_CHAIN);
    const blockHash = yield api.rpc.chain.getBlockHash(blockNumber);
    const signedBlock = yield api.rpc.chain.getBlock(blockHash);
    const timestampNow = signedBlock.block.extrinsics[0].method.args;
    const formatedTimestamp = timestampNow.toString().slice(0, -3);
    const date = new Date(Number(formatedTimestamp) * 1000);
    return date;
});
exports.blockNumberToDate = blockNumberToDate;
