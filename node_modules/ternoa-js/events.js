"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NFTUnlistedEvent = exports.NFTListedEvent = exports.MarketplaceMintFeeSetEvent = exports.MarketplaceKindSetEvent = exports.MarketplaceOwnerSetEvent = exports.MarketplaceConfigSetEvent = exports.MarketplaceCreatedEvent = exports.ContractExpiredEvent = exports.ContractSubscriptionPeriodStartedEvent = exports.ContractEndedEvent = exports.ContractSubscriptionTermsAcceptedEvent = exports.ContractSubscriptionTermsChangedEvent = exports.ContractOfferRetractedEvent = exports.ContractOfferCreatedEvent = exports.ContractRevokedEvent = exports.ContractStartedEvent = exports.ContractCanceledEvent = exports.ContractCreatedEvent = exports.RewardsClaimedEvent = exports.MetricsServerReportSubmittedEvent = exports.TransmittedEvent = exports.ThresholdReachedEvent = exports.ConsentAddedEvent = exports.TimerResetEvent = exports.ProtocolRemovedEvent = exports.ProtocolSetEvent = exports.CapsuleRevertedEvent = exports.CapsuleKeyUpdateNotifiedEvent = exports.CapsuleOffchainDataSetEvent = exports.NFTConvertedToCapsuleEvent = exports.CollectionOffchainDataSetEvent = exports.CollectionBurnedEvent = exports.CollectionClosedEvent = exports.CollectionLimitedEvent = exports.CollectionCreatedEvent = exports.NFTAddedToCollectionEvent = exports.NFTTransferredEvent = exports.NFTRoyaltySetEvent = exports.NFTDelegatedEvent = exports.NFTBurnedEvent = exports.SecretAddedToNFTEvent = exports.NFTCreatedEvent = exports.TreasuryDepositEvent = exports.BalancesEndowedEvent = exports.BalancesTransferEvent = exports.BalancesDepositEvent = exports.BalancesWithdrawEvent = exports.AssetTransferredEvent = exports.BlockchainEvent = exports.EventType = void 0;
exports.BlockchainEvents = exports.UnknownEvent = exports.NewAccountEvent = exports.ExtrinsicSuccessEvent = exports.ExtrinsicFailedEvent = exports.BatchCompletedEvent = exports.BatchCompletedWithErrorsEvent = exports.BatchInterruptedEvent = exports.ItemFailedEvent = exports.ItemCompletedEvent = exports.BalanceClaimedEvent = exports.BidRemovedEvent = exports.BidAddedEvent = exports.AuctionCompletedEvent = exports.AuctionCancelledEvent = exports.AuctionCreatedEvent = exports.NFTSoldEvent = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const util_1 = require("@polkadot/util");
const constants_1 = require("./constants");
const utils_1 = require("./helpers/utils");
const enum_1 = require("./marketplace/enum");
const enum_2 = require("./rent/enum");
var EventType;
(function (EventType) {
    //Assets
    EventType["AssetTransferred"] = "assets.Transferred";
    // Balances
    EventType["BalancesWithdraw"] = "balances.Withdraw";
    EventType["BalancesDeposit"] = "balances.Deposit";
    EventType["BalancesTransfer"] = "balances.Transfer";
    EventType["BalancesEndowed"] = "balances.Endowed";
    // Treasury
    EventType["TreasuryDeposit"] = "treasury.Deposit";
    // NFT
    EventType["NFTCreated"] = "nft.NFTCreated";
    EventType["SecretAddedToNFT"] = "nft.SecretAddedToNFT";
    EventType["NFTBurned"] = "nft.NFTBurned";
    EventType["NFTDelegated"] = "nft.NFTDelegated";
    EventType["NFTRoyaltySet"] = "nft.NFTRoyaltySet";
    EventType["NFTTransferred"] = "nft.NFTTransferred";
    EventType["NFTAddedToCollection"] = "nft.NFTAddedToCollection";
    // NFT Capsule
    EventType["NFTConvertedToCapsule"] = "nft.NFTConvertedToCapsule";
    EventType["CapsuleOffchainDataSet"] = "nft.CapsuleOffchainDataSet";
    EventType["CapsuleKeyUpdateNotified"] = "nft.CapsuleKeyUpdateNotified";
    EventType["CapsuleReverted"] = "nft.CapsuleReverted";
    // NFT Collections
    EventType["CollectionCreated"] = "nft.CollectionCreated";
    EventType["CollectionLimited"] = "nft.CollectionLimited";
    EventType["CollectionClosed"] = "nft.CollectionClosed";
    EventType["CollectionBurned"] = "nft.CollectionBurned";
    EventType["CollectionOffchainDataSet"] = "nft.CollectionOffchainDataSet";
    //Transmission Protocols
    EventType["ProtocolSet"] = "transmissionProtocols.ProtocolSet";
    EventType["ProtocolRemoved"] = "transmissionProtocols.ProtocolRemoved";
    EventType["TimerReset"] = "transmissionProtocols.TimerReset";
    EventType["ConsentAdded"] = "transmissionProtocols.ConsentAdded";
    EventType["ThresholdReached"] = "transmissionProtocols.ThresholdReached";
    EventType["Transmitted"] = "transmissionProtocols.Transmitted";
    //Rent
    EventType["ContractCreated"] = "rent.ContractCreated";
    EventType["ContractStarted"] = "rent.ContractStarted";
    EventType["ContractRevoked"] = "rent.ContractRevoked";
    EventType["ContractOfferCreated"] = "rent.ContractOfferCreated";
    EventType["ContractOfferRetracted"] = "rent.ContractOfferRetracted";
    EventType["ContractSubscriptionTermsChanged"] = "rent.ContractSubscriptionTermsChanged";
    EventType["ContractSubscriptionTermsAccepted"] = "rent.ContractSubscriptionTermsAccepted";
    EventType["ContractEnded"] = "rent.ContractEnded";
    EventType["ContractSubscriptionPeriodStarted"] = "rent.ContractSubscriptionPeriodStarted";
    EventType["ContractExpired"] = "rent.ContractExpired";
    EventType["ContractCanceled"] = "rent.ContractCanceled";
    // Marketplace
    EventType["MarketplaceCreated"] = "marketplace.MarketplaceCreated";
    EventType["MarketplaceOwnerSet"] = "marketplace.MarketplaceOwnerSet";
    EventType["MarketplaceKindSet"] = "marketplace.MarketplaceKindSet";
    EventType["MarketplaceConfigSet"] = "marketplace.MarketplaceConfigSet";
    EventType["MarketplaceMintFeeSet"] = "marketplace.MarketplaceMintFeeSet";
    EventType["NFTListed"] = "marketplace.NFTListed";
    EventType["NFTUnlisted"] = "marketplace.NFTUnlisted";
    EventType["NFTSold"] = "marketplace.NFTSold";
    // Auctions
    EventType["AuctionCreated"] = "auction.AuctionCreated";
    EventType["AuctionCancelled"] = "auction.AuctionCancelled";
    EventType["AuctionCompleted"] = "auction.AuctionCompleted";
    EventType["BidAdded"] = "auction.BidAdded";
    EventType["BidRemoved"] = "auction.BidRemoved";
    EventType["BalanceClaimed"] = "auction.BalanceClaimed";
    // Utility
    EventType["ItemFailed"] = "utility.ItemFailed";
    EventType["ItemCompleted"] = "utility.ItemCompleted";
    EventType["BatchInterrupted"] = "utility.BatchInterrupted";
    EventType["BatchCompletedWithErrors"] = "utility.BatchCompletedWithErrors";
    EventType["BatchCompleted"] = "utility.BatchCompleted";
    // System
    EventType["ExtrinsicFailed"] = "system.ExtrinsicFailed";
    EventType["ExtrinsicSuccess"] = "system.ExtrinsicSuccess";
    EventType["NewAccount"] = "system.NewAccount";
    // Tee
    EventType["MetricsServerReportSubmitted"] = "tee.MetricsServerReportSubmitted";
    EventType["RewardsClaimed"] = "tee.RewardsClaimed";
    // Unknown
    EventType["Unknown"] = "Unknown";
})(EventType || (exports.EventType = EventType = {}));
class BlockchainEvent {
    constructor(raw, type) {
        this.raw = raw;
        this.type = type;
        this.section = raw.section;
        this.method = raw.method;
    }
    static fromEvent(event) {
        const name = event.section + "." + event.method;
        switch (name) {
            // Assets
            case EventType.AssetTransferred:
                return new AssetTransferredEvent(event);
            // Balances
            case EventType.BalancesWithdraw:
                return new BalancesWithdrawEvent(event);
            case EventType.BalancesDeposit:
                return new BalancesDepositEvent(event);
            case EventType.BalancesTransfer:
                return new BalancesTransferEvent(event);
            case EventType.BalancesEndowed:
                return new BalancesEndowedEvent(event);
            // Treasury
            case EventType.TreasuryDeposit:
                return new TreasuryDepositEvent(event);
            // NFT
            case EventType.NFTCreated:
                return new NFTCreatedEvent(event);
            case EventType.SecretAddedToNFT:
                return new SecretAddedToNFTEvent(event);
            case EventType.NFTBurned:
                return new NFTBurnedEvent(event);
            case EventType.NFTDelegated:
                return new NFTDelegatedEvent(event);
            case EventType.NFTRoyaltySet:
                return new NFTRoyaltySetEvent(event);
            case EventType.NFTTransferred:
                return new NFTTransferredEvent(event);
            case EventType.NFTAddedToCollection:
                return new NFTAddedToCollectionEvent(event);
            case EventType.CollectionCreated:
                return new CollectionCreatedEvent(event);
            case EventType.CollectionLimited:
                return new CollectionLimitedEvent(event);
            case EventType.CollectionClosed:
                return new CollectionClosedEvent(event);
            case EventType.CollectionBurned:
                return new CollectionBurnedEvent(event);
            case EventType.CollectionOffchainDataSet:
                return new CollectionOffchainDataSetEvent(event);
            // Capsule
            case EventType.NFTConvertedToCapsule:
                return new NFTConvertedToCapsuleEvent(event);
            case EventType.CapsuleOffchainDataSet:
                return new CapsuleOffchainDataSetEvent(event);
            case EventType.CapsuleKeyUpdateNotified:
                return new CapsuleKeyUpdateNotifiedEvent(event);
            case EventType.CapsuleReverted:
                return new CapsuleRevertedEvent(event);
            // Transmission Protocols
            case EventType.ProtocolSet:
                return new ProtocolSetEvent(event);
            case EventType.ProtocolRemoved:
                return new ProtocolRemovedEvent(event);
            case EventType.TimerReset:
                return new TimerResetEvent(event);
            case EventType.ConsentAdded:
                return new ConsentAddedEvent(event);
            case EventType.ThresholdReached:
                return new ThresholdReachedEvent(event);
            case EventType.Transmitted:
                return new TransmittedEvent(event);
            // Tee
            case EventType.MetricsServerReportSubmitted:
                return new MetricsServerReportSubmittedEvent(event);
            case EventType.RewardsClaimed:
                return new RewardsClaimedEvent(event);
            // Rent
            case EventType.ContractCreated:
                return new ContractCreatedEvent(event);
            case EventType.ContractCanceled:
                return new ContractCanceledEvent(event);
            case EventType.ContractStarted:
                return new ContractStartedEvent(event);
            case EventType.ContractRevoked:
                return new ContractRevokedEvent(event);
            case EventType.ContractOfferCreated:
                return new ContractOfferCreatedEvent(event);
            case EventType.ContractOfferRetracted:
                return new ContractOfferRetractedEvent(event);
            case EventType.ContractSubscriptionTermsChanged:
                return new ContractSubscriptionTermsChangedEvent(event);
            case EventType.ContractSubscriptionTermsAccepted:
                return new ContractSubscriptionTermsAcceptedEvent(event);
            case EventType.ContractEnded:
                return new ContractEndedEvent(event);
            case EventType.ContractSubscriptionPeriodStarted:
                return new ContractSubscriptionPeriodStartedEvent(event);
            case EventType.ContractExpired:
                return new ContractExpiredEvent(event);
            // Marketplace
            case EventType.MarketplaceCreated:
                return new MarketplaceCreatedEvent(event);
            case EventType.MarketplaceOwnerSet:
                return new MarketplaceOwnerSetEvent(event);
            case EventType.MarketplaceKindSet:
                return new MarketplaceKindSetEvent(event);
            case EventType.MarketplaceConfigSet:
                return new MarketplaceConfigSetEvent(event);
            case EventType.MarketplaceMintFeeSet:
                return new MarketplaceMintFeeSetEvent(event);
            case EventType.NFTListed:
                return new NFTListedEvent(event);
            case EventType.NFTUnlisted:
                return new NFTUnlistedEvent(event);
            case EventType.NFTSold:
                return new NFTSoldEvent(event);
            // Auctions
            case EventType.AuctionCreated:
                return new AuctionCreatedEvent(event);
            case EventType.AuctionCancelled:
                return new AuctionCancelledEvent(event);
            case EventType.AuctionCompleted:
                return new AuctionCompletedEvent(event);
            case EventType.BidAdded:
                return new BidAddedEvent(event);
            case EventType.BidRemoved:
                return new BidRemovedEvent(event);
            case EventType.BalanceClaimed:
                return new BalanceClaimedEvent(event);
            // Utility
            case EventType.ItemCompleted:
                return new ItemCompletedEvent(event);
            case EventType.ItemFailed:
                return new ItemFailedEvent(event);
            case EventType.BatchInterrupted:
                return new BatchInterruptedEvent(event);
            case EventType.BatchCompletedWithErrors:
                return new BatchCompletedWithErrorsEvent(event);
            case EventType.BatchCompleted:
                return new BatchCompletedEvent(event);
            // System
            case EventType.ExtrinsicFailed:
                return new ExtrinsicFailedEvent(event);
            case EventType.ExtrinsicSuccess:
                return new ExtrinsicSuccessEvent(event);
            case EventType.NewAccount:
                return new NewAccountEvent(event);
        }
        return new UnknownEvent(event);
    }
}
exports.BlockchainEvent = BlockchainEvent;
/**
 * This class represents the on-chain AssetTransferredEvent event.
 */
class AssetTransferredEvent extends BlockchainEvent {
    /**
     * Construct the data object from the AssetTransferredEvent event
     * @param event The AssetTransferredEvent event
     */
    constructor(event) {
        super(event, EventType.AssetTransferred);
        const [assetId, from, to, amount] = event.data;
        this.assetId = Number.parseInt(assetId.toString());
        this.from = from.toString();
        this.to = to.toString();
        this.amount = (0, util_1.bnToBn)(amount.toString()).toString();
        this.amountRounded = (0, utils_1.roundBalance)(this.amount);
    }
}
exports.AssetTransferredEvent = AssetTransferredEvent;
/**
 * This class represents the on-chain BalancesWithdrawEvent event.
 */
class BalancesWithdrawEvent extends BlockchainEvent {
    /**
     * Construct the data object from the BalancesWithdrawEvent event
     * @param event The BalancesWithdrawEvent event
     */
    constructor(event) {
        super(event, EventType.BalancesWithdraw);
        this.who = event.data[0].toString();
        this.amount = event.data[1].toString();
        this.amountRounded = (0, utils_1.roundBalance)(this.amount);
    }
}
exports.BalancesWithdrawEvent = BalancesWithdrawEvent;
/**
 * This class represents the on-chain BalancesDepositEvent event.
 */
class BalancesDepositEvent extends BlockchainEvent {
    /**
     * Construct the data object from the BalancesDepositEvent event
     * @param event The BalancesDepositEvent event
     */
    constructor(event) {
        super(event, EventType.BalancesDeposit);
        const [who, amount] = event.data;
        this.who = who.toString();
        this.amount = amount.toString();
        this.amountRounded = (0, utils_1.roundBalance)(this.amount);
    }
}
exports.BalancesDepositEvent = BalancesDepositEvent;
/**
 * This class represents the on-chain BalancesTransferEvent event.
 */
class BalancesTransferEvent extends BlockchainEvent {
    /**
     * Construct the data object from the BalancesTransferEvent event
     * @param event The BalancesTransferEvent event
     */
    constructor(event) {
        super(event, EventType.BalancesTransfer);
        const [from, to, amount] = event.data;
        this.from = from.toString();
        this.to = to.toString();
        this.amount = amount.toString();
        this.amountRounded = (0, utils_1.roundBalance)(this.amount);
    }
}
exports.BalancesTransferEvent = BalancesTransferEvent;
/**
 *  This class represents the on-chain BalancesEndowedEvent event.
 */
class BalancesEndowedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the BalancesEndowedEvent event
     * @param event The BalancesEndowedEvent event
     */
    constructor(event) {
        super(event, EventType.BalancesEndowed);
        const [account, freeBalance] = event.data;
        this.account = account.toString();
        this.freeBalance = freeBalance.toString();
        this.freeBalanceRounded = (0, utils_1.roundBalance)(this.freeBalance);
    }
}
exports.BalancesEndowedEvent = BalancesEndowedEvent;
/**
 * This class represents the on-chain TreasuryDepositEvent event.
 */
class TreasuryDepositEvent extends BlockchainEvent {
    /**
     * Construct the data object the TreasuryDepositEvent event
     * @param event The TreasuryDepositEvent event
     */
    constructor(event) {
        super(event, EventType.TreasuryDeposit);
        const [value] = event.data;
        this.value = value.toString();
        this.valueRounded = (0, utils_1.roundBalance)(this.value);
    }
}
exports.TreasuryDepositEvent = TreasuryDepositEvent;
/**
 * This class represents the on-chain NFTCreatedEvent event.
 */
class NFTCreatedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the NFTCreatedEvent event
     * @param event The NFTCreatedEvent event
     */
    constructor(event) {
        super(event, EventType.NFTCreated);
        const [nftId, owner, offchainData, royalty, collectionId, isSoulbound, mintFee] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.owner = owner.toString();
        this.royalty = Number.parseInt(royalty.toString()) / 10000;
        this.collectionId = Number.parseInt(collectionId.toString()) || null;
        this.isSoulbound = isSoulbound.toString() === "true";
        this.offchainData = (0, util_1.hexToString)(offchainData.toString());
        this.mintFee = mintFee.toString();
        this.mintFeeRounded = (0, utils_1.roundBalance)(this.mintFee);
    }
}
exports.NFTCreatedEvent = NFTCreatedEvent;
class SecretAddedToNFTEvent extends BlockchainEvent {
    /**
     * Construct the data object from the SecretAddedToNFTEvent event
     * @param event The SecretAddedToNFTEvent event
     */
    constructor(event) {
        super(event, EventType.SecretAddedToNFT);
        const [nftId, offchainData] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.offchainData = (0, util_1.hexToString)(offchainData.toString());
    }
}
exports.SecretAddedToNFTEvent = SecretAddedToNFTEvent;
/**
 * This class represents the on-chain NFTBurnedEvent event.
 */
class NFTBurnedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the NFTBurnedEvent event
     * @param event The NFTBurnedEvent event
     */
    constructor(event) {
        super(event, EventType.NFTBurned);
        const [nftId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
    }
}
exports.NFTBurnedEvent = NFTBurnedEvent;
/**
 * This class represents the on-chain NFTDelegatedEvent event.
 */
class NFTDelegatedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the NFTDelegatedEvent event
     * @param event The NFTDelegatedEvent event
     */
    constructor(event) {
        super(event, EventType.NFTDelegated);
        const [nftId, recipient] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.recipient = (recipient === null || recipient === void 0 ? void 0 : recipient.toString()) || null;
    }
}
exports.NFTDelegatedEvent = NFTDelegatedEvent;
/**
 * This class represents the on-chain NFTRoyaltySetEvent event.
 */
class NFTRoyaltySetEvent extends BlockchainEvent {
    /**
     * Construct the data object from the NFTRoyaltySetEvent event
     * @param event The NFTRoyaltySetEvent event
     */
    constructor(event) {
        super(event, EventType.NFTRoyaltySet);
        const [nftId, royalty] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.royalty = Number.parseInt(royalty.toString()) / 10000;
    }
}
exports.NFTRoyaltySetEvent = NFTRoyaltySetEvent;
/**
 * This class represents the on-chain NFTTransferredEvent event.
 */
class NFTTransferredEvent extends BlockchainEvent {
    /**
     * Construct the data object from the NFTTransferredEvent event
     * @param event The NFTTransferredEvent event
     */
    constructor(event) {
        super(event, EventType.NFTTransferred);
        const [nftId, sender, recipient] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.sender = sender.toString();
        this.recipient = recipient.toString();
    }
}
exports.NFTTransferredEvent = NFTTransferredEvent;
/**
 * This class represents the on-chain NFTAddedToCollectionEvent event.
 */
class NFTAddedToCollectionEvent extends BlockchainEvent {
    /**
     * Construct the data object from the NFTAddedToCollectionEvent event
     * @param event The NFTAddedToCollectionEvent event
     */
    constructor(event) {
        super(event, EventType.NFTAddedToCollection);
        const [nftId, collectionId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.collectionId = Number.parseInt(collectionId.toString());
    }
}
exports.NFTAddedToCollectionEvent = NFTAddedToCollectionEvent;
/**
 * This class represents the on-chain CollectionCreatedEvent event.
 */
class CollectionCreatedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the CollectionCreatedEvent event
     * @param event The CollectionCreatedEvent event
     */
    constructor(event) {
        super(event, EventType.CollectionCreated);
        const [collectionId, owner, offchainData, limit] = event.data;
        this.collectionId = Number.parseInt(collectionId.toString());
        this.owner = owner.toString();
        this.limit = Number.parseInt(limit.toString()) || null;
        this.offchainData = (0, util_1.hexToString)(offchainData.toString());
    }
}
exports.CollectionCreatedEvent = CollectionCreatedEvent;
/**
 * This class represents the on-chain blockchain CollectionLimitedEvent event.
 */
class CollectionLimitedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the CollectionLimitedEvent event
     * @param event The CollectionLimitedEvent event
     */
    constructor(event) {
        super(event, EventType.CollectionLimited);
        const [collectionId, limit] = event.data;
        this.collectionId = Number.parseInt(collectionId.toString());
        this.limit = Number.parseInt(limit.toString());
    }
}
exports.CollectionLimitedEvent = CollectionLimitedEvent;
/**
 * This class represents the on-chain CollectionClosedEvent event.
 */
class CollectionClosedEvent extends BlockchainEvent {
    /**
     * Construct the data object from theCollectionClosedEvent event
     * @param event The CollectionClosedEvent event
     */
    constructor(event) {
        super(event, EventType.CollectionClosed);
        const [collectionId] = event.data;
        this.collectionId = Number.parseInt(collectionId.toString());
    }
}
exports.CollectionClosedEvent = CollectionClosedEvent;
/**
 * This class represents the on-chain CollectionBurnedEvent event.
 */
class CollectionBurnedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the CollectionBurnedEvent event
     * @param event The CollectionBurnedEvent event
     */
    constructor(event) {
        super(event, EventType.CollectionBurned);
        const [collectionId] = event.data;
        this.collectionId = Number.parseInt(collectionId.toString());
    }
}
exports.CollectionBurnedEvent = CollectionBurnedEvent;
/**
 * This class represents the on-chain CollectionBurnedEvent event.
 */
class CollectionOffchainDataSetEvent extends BlockchainEvent {
    /**
     * Construct the data object from the CollectionBurnedEvent event
     * @param event The CollectionBurnedEvent event
     */
    constructor(event) {
        super(event, EventType.CollectionOffchainDataSet);
        const [collectionId, offchainData] = event.data;
        this.collectionId = Number.parseInt(collectionId.toString());
        this.offchainData = (0, util_1.hexToString)(offchainData.toString());
    }
}
exports.CollectionOffchainDataSetEvent = CollectionOffchainDataSetEvent;
/**
 * This class represents the on-chain NFTConvertedToCapsuleEvent event.
 */
class NFTConvertedToCapsuleEvent extends BlockchainEvent {
    /**
     * Construct the data object from the NFTConvertedToCapsuleEvent event
     * @param event The NFTConvertedToCapsuleEvent event
     */
    constructor(event) {
        super(event, EventType.NFTConvertedToCapsule);
        const [nftId, offchainData] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.offchainData = (0, util_1.hexToString)(offchainData.toString());
    }
}
exports.NFTConvertedToCapsuleEvent = NFTConvertedToCapsuleEvent;
/**
 * This class represents the on-chain CapsuleOffchainDataSetEvent event.
 */
class CapsuleOffchainDataSetEvent extends BlockchainEvent {
    /**
     * Construct the data object from the CapsuleOffchainDataSetEvent event
     * @param event The CapsuleOffchainDataSetEvent event
     */
    constructor(event) {
        super(event, EventType.CapsuleOffchainDataSet);
        const [nftId, offchainData] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.offchainData = (0, util_1.hexToString)(offchainData.toString());
    }
}
exports.CapsuleOffchainDataSetEvent = CapsuleOffchainDataSetEvent;
/**
 * This class represents the on-chain CapsuleKeyUpdateNotifiedEvent event.
 */
class CapsuleKeyUpdateNotifiedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the CapsuleKeyUpdateNotifiedEvent event
     * @param event The CapsuleKeyUpdateNotifiedEvent event
     */
    constructor(event) {
        super(event, EventType.CapsuleKeyUpdateNotified);
        const [nftId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
    }
}
exports.CapsuleKeyUpdateNotifiedEvent = CapsuleKeyUpdateNotifiedEvent;
/**
 * This class represents the on-chain CapsuleRevertedEvent event.
 */
class CapsuleRevertedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the CapsuleRevertedEvent event
     * @param event The CapsuleRevertedEvent event
     */
    constructor(event) {
        super(event, EventType.CapsuleReverted);
        const [nftId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
    }
}
exports.CapsuleRevertedEvent = CapsuleRevertedEvent;
/**
 * This class represents the on-chain ProtocolSetEvent event.
 */
class ProtocolSetEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ProtocolSetEvent event
     * @param event The ProtocolSetEvent event
     */
    constructor(event) {
        super(event, EventType.ProtocolSet);
        const [nftId, recipient, protocol, cancellation] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.recipient = recipient.toString();
        this.protocol = protocol.toJSON();
        this.cancellation = cancellation.toJSON();
    }
}
exports.ProtocolSetEvent = ProtocolSetEvent;
/**
 * This class represents the on-chain ProtocolRemovedEvent event.
 */
class ProtocolRemovedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ProtocolRemovedEvent event
     * @param event The ProtocolRemovedEvent event
     */
    constructor(event) {
        super(event, EventType.ProtocolRemoved);
        const [nftId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
    }
}
exports.ProtocolRemovedEvent = ProtocolRemovedEvent;
/**
 * This class represents the on-chain TimerResetEvent event.
 */
class TimerResetEvent extends BlockchainEvent {
    /**
     * Construct the data object from the TimerResetEvent event
     * @param event The TimerResetEvent event
     */
    constructor(event) {
        super(event, EventType.TimerReset);
        const [nftId, newBlockNumber] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.newBlockNumber = Number.parseInt(newBlockNumber.toString());
    }
}
exports.TimerResetEvent = TimerResetEvent;
/**
 * This class represents the on-chain ConsentAddedEvent event.
 */
class ConsentAddedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ConsentAddedEvent event
     * @param event The ConsentAddedEvent event
     */
    constructor(event) {
        super(event, EventType.ConsentAdded);
        const [nftId, from] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.from = from.toString();
    }
}
exports.ConsentAddedEvent = ConsentAddedEvent;
/**
 * This class represents the on-chain ThresholdReachedEvent event.
 */
class ThresholdReachedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ThresholdReachedEvent event
     * @param event The ThresholdReachedEvent event
     */
    constructor(event) {
        super(event, EventType.ThresholdReached);
        const [nftId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
    }
}
exports.ThresholdReachedEvent = ThresholdReachedEvent;
/**
 * This class represents the on-chain TransmittedEvent event.
 */
class TransmittedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the TransmittedEvent event
     * @param event The TransmittedEvent event
     */
    constructor(event) {
        super(event, EventType.Transmitted);
        const [nftId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
    }
}
exports.TransmittedEvent = TransmittedEvent;
/**
 * This class represents the on-chain MetricsServerReportSubmitted event.
 */
class MetricsServerReportSubmittedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the MetricsServerReportSubmittedEvent event
     * @param event The MetricsServerReportSubmittedEvent event
     */
    constructor(event) {
        super(event, EventType.MetricsServerReportSubmitted);
        const [era, operatorAddress, metricsServerReport] = event.data;
        this.era = Number.parseInt(era.toString());
        this.operatorAddress = operatorAddress.toString();
        this.metricsServerReport = metricsServerReport.toJSON();
    }
}
exports.MetricsServerReportSubmittedEvent = MetricsServerReportSubmittedEvent;
/**
 * This class represents the on-chain RewardsClaimed event.
 */
class RewardsClaimedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the RewardsClaimedEvent event
     * @param event The RewardsClaimedEvent event
     */
    constructor(event) {
        super(event, EventType.RewardsClaimed);
        const [era, operatorAddress, amount] = event.data;
        this.era = Number.parseInt(era.toString());
        this.operatorAddress = operatorAddress.toString();
        this.amount = (0, util_1.bnToBn)(amount.toString()).toString();
        this.amountRounded = (0, utils_1.roundBalance)(this.amount);
    }
}
exports.RewardsClaimedEvent = RewardsClaimedEvent;
/**
 * This class represents the on-chain ContractCreatedEvent event.
 */
class ContractCreatedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ContractCreatedEvent event
     * @param event The ContractCreatedEvent event
     */
    constructor(event) {
        var _a, _b, _c, _d;
        super(event, EventType.ContractCreated);
        const [nftId, renter, duration, acceptanceType, renterCanRevoke, rentFee, renterCancellationFee, renteeCancellationFee,] = event.data;
        const parsedDuration = JSON.parse(duration.toString());
        const parsedAcceptance = JSON.parse(acceptanceType.toString());
        const isAutoAcceptance = enum_2.AcceptanceAction.AutoAcceptance in parsedAcceptance;
        const parsedRentFee = JSON.parse(rentFee.toString());
        const isRentFeeToken = enum_2.RentFeeAction.Tokens in parsedRentFee;
        const parsedRenterCancellationFee = renterCancellationFee.toString() !== enum_2.CancellationFeeAction.None && JSON.parse(renterCancellationFee.toString());
        const parsedRenteeCancellationFee = renteeCancellationFee.toString() !== enum_2.CancellationFeeAction.None && JSON.parse(renteeCancellationFee.toString());
        this.creationBlockId = 0;
        this.nftId = Number.parseInt(nftId.toString());
        this.renter = renter.toString();
        this.duration = parsedDuration;
        this.renterCanRevoke = renterCanRevoke.toString() === "true";
        if (isAutoAcceptance) {
            this.acceptanceType = enum_2.AcceptanceAction.AutoAcceptance;
            this.acceptanceList = (_b = (_a = parsedAcceptance.autoAcceptance) === null || _a === void 0 ? void 0 : _a.map((account) => account)) !== null && _b !== void 0 ? _b : [];
        }
        else {
            this.acceptanceType = enum_2.AcceptanceAction.ManualAcceptance;
            this.acceptanceList = (_d = (_c = parsedAcceptance.manualAcceptance) === null || _c === void 0 ? void 0 : _c.map((account) => account)) !== null && _d !== void 0 ? _d : [];
        }
        if (isRentFeeToken) {
            this.rentFeeType = enum_2.RentFeeAction.Tokens;
            this.rentFee = (0, util_1.bnToBn)(parsedRentFee[this.rentFeeType]).toString();
            this.rentFeeRounded = (0, utils_1.roundBalance)(this.rentFee);
        }
        else {
            this.rentFeeType = enum_2.RentFeeAction.NFT;
            this.rentFee = Number.parseInt(parsedRentFee[this.rentFeeType].toString());
            this.rentFeeRounded = this.rentFee;
        }
        switch (true) {
            case parsedRenterCancellationFee && enum_2.CancellationFeeAction.FixedTokens in parsedRenterCancellationFee:
                this.renterCancellationFeeType = enum_2.CancellationFeeAction.FixedTokens;
                this.renterCancellationFee = (0, util_1.bnToBn)(parsedRenterCancellationFee[this.renterCancellationFeeType]).toString();
                this.renterCancellationFeeRounded = (0, utils_1.roundBalance)(this.renterCancellationFee);
                break;
            case parsedRenterCancellationFee && enum_2.CancellationFeeAction.FlexibleTokens in parsedRenterCancellationFee:
                this.renterCancellationFeeType = enum_2.CancellationFeeAction.FlexibleTokens;
                this.renterCancellationFee = (0, util_1.bnToBn)(parsedRenterCancellationFee[this.renterCancellationFeeType]).toString();
                this.renterCancellationFeeRounded = (0, utils_1.roundBalance)(this.renterCancellationFee);
                break;
            case parsedRenterCancellationFee && enum_2.CancellationFeeAction.NFT in parsedRenterCancellationFee:
                this.renterCancellationFeeType = enum_2.CancellationFeeAction.NFT;
                this.renterCancellationFee = Number(parsedRenterCancellationFee[this.renterCancellationFeeType]);
                this.renterCancellationFeeRounded = this.renterCancellationFee;
                break;
            default:
                this.renterCancellationFeeType = enum_2.CancellationFeeAction.None;
                this.renterCancellationFee = null;
                this.renterCancellationFeeRounded = null;
                break;
        }
        switch (true) {
            case parsedRenteeCancellationFee && enum_2.CancellationFeeAction.FixedTokens in parsedRenteeCancellationFee:
                this.renteeCancellationFeeType = enum_2.CancellationFeeAction.FixedTokens;
                this.renteeCancellationFee = (0, util_1.bnToBn)(parsedRenteeCancellationFee[this.renteeCancellationFeeType]).toString();
                this.renteeCancellationFeeRounded = (0, utils_1.roundBalance)(this.renteeCancellationFee);
                break;
            case parsedRenteeCancellationFee && enum_2.CancellationFeeAction.FlexibleTokens in parsedRenteeCancellationFee:
                this.renteeCancellationFeeType = enum_2.CancellationFeeAction.FlexibleTokens;
                this.renteeCancellationFee = (0, util_1.bnToBn)(parsedRenteeCancellationFee[this.renteeCancellationFeeType]).toString();
                this.renteeCancellationFeeRounded = (0, utils_1.roundBalance)(this.renteeCancellationFee);
                break;
            case parsedRenteeCancellationFee && enum_2.CancellationFeeAction.NFT in parsedRenteeCancellationFee:
                this.renteeCancellationFeeType = enum_2.CancellationFeeAction.NFT;
                this.renteeCancellationFee = Number(parsedRenteeCancellationFee[this.renteeCancellationFeeType]);
                this.renteeCancellationFeeRounded = this.renteeCancellationFee;
                break;
            default:
                this.renteeCancellationFeeType = enum_2.CancellationFeeAction.None;
                this.renteeCancellationFee = null;
                this.renteeCancellationFeeRounded = null;
                break;
        }
    }
}
exports.ContractCreatedEvent = ContractCreatedEvent;
/**
 * This class represents the on-chain ContractCanceledEvent event.
 */
class ContractCanceledEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ContractCanceledEvent event
     * @param event The ContractCanceledEvent event
     */
    constructor(event) {
        super(event, EventType.ContractCanceled);
        const [nftId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
    }
}
exports.ContractCanceledEvent = ContractCanceledEvent;
/**
 * This class represents the on-chain ContractStartedEvent event.
 */
class ContractStartedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ContractStartedEvent event
     * @param event The ContractStartedEvent event
     */
    constructor(event) {
        super(event, EventType.ContractStarted);
        const [nftId, rentee] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.rentee = rentee.toString();
    }
}
exports.ContractStartedEvent = ContractStartedEvent;
/**
 * This class represents the on-chain ContractRevokedEvent event.
 */
class ContractRevokedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ContractRevokedEvent event
     * @param event The ContractRevokedEvent event
     */
    constructor(event) {
        super(event, EventType.ContractRevoked);
        const [nftId, revokedBy] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.revokedBy = revokedBy.toString();
    }
}
exports.ContractRevokedEvent = ContractRevokedEvent;
/**
 * This class represents the on-chain ContractOfferCreatedEvent event.
 */
class ContractOfferCreatedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ContractOfferCreatedEvent event
     * @param event The ContractOfferCreatedEvent event
     */
    constructor(event) {
        super(event, EventType.ContractOfferCreated);
        const [nftId, rentee] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.rentee = rentee.toString();
    }
}
exports.ContractOfferCreatedEvent = ContractOfferCreatedEvent;
/**
 * This class represents the on-chain ContractOfferRetractedEvent event.
 */
class ContractOfferRetractedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ContractOfferRetractedEvent event
     * @param event The ContractOfferRetractedEvent event
     */
    constructor(event) {
        super(event, EventType.ContractOfferRetracted);
        const [nftId, rentee] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.rentee = rentee.toString();
    }
}
exports.ContractOfferRetractedEvent = ContractOfferRetractedEvent;
/**
 * This class represents the on-chain ContractSubscriptionTermsChangedEvent event.
 */
class ContractSubscriptionTermsChangedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ContractSubscriptionTermsChangedEvent event
     * @param event The ContractSubscriptionTermsChangedEvent event
     */
    constructor(event) {
        super(event, EventType.ContractSubscriptionTermsChanged);
        const [nftId, period, maxDuration, isChangeable, rentFee] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.period = Number.parseInt(period.toString());
        this.maxDuration = Number.parseInt(maxDuration.toString());
        this.isChangeable = Boolean(isChangeable.toString() === "true");
        this.rentFeeType = enum_2.RentFeeAction.Tokens;
        this.rentFee = (0, util_1.bnToBn)(rentFee.toString()).toString();
        this.rentFeeRounded = (0, utils_1.roundBalance)(this.rentFee);
    }
}
exports.ContractSubscriptionTermsChangedEvent = ContractSubscriptionTermsChangedEvent;
/**
 * This class represents the on-chain ContractSubscriptionTermsAcceptedEvent event.
 */
class ContractSubscriptionTermsAcceptedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ContractSubscriptionTermsAcceptedEvent event
     * @param event The ContractSubscriptionTermsAcceptedEvent event
     */
    constructor(event) {
        super(event, EventType.ContractSubscriptionTermsAccepted);
        const [nftId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
    }
}
exports.ContractSubscriptionTermsAcceptedEvent = ContractSubscriptionTermsAcceptedEvent;
/**
 * This class represents the on-chain ContractEndedEvent event.
 */
class ContractEndedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ContractEndedEvent event
     * @param event The ContractEndedEvent event
     */
    constructor(event) {
        super(event, EventType.ContractEnded);
        const [nftId, revokedBy] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.revokedBy = revokedBy.toString();
    }
}
exports.ContractEndedEvent = ContractEndedEvent;
/**
 * This class represents the on-chain ContractSubscriptionPeriodStartedEvent event.
 */
class ContractSubscriptionPeriodStartedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ContractSubscriptionPeriodStartedEvent event
     * @param event The ContractSubscriptionPeriodStartedEvent event
     */
    constructor(event) {
        super(event, EventType.ContractSubscriptionPeriodStarted);
        const [nftId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
    }
}
exports.ContractSubscriptionPeriodStartedEvent = ContractSubscriptionPeriodStartedEvent;
/**
 * This class represents the on-chain ContractExpiredEvent event.
 */
class ContractExpiredEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ContractExpiredEvent event
     * @param event The ContractExpiredEvent event
     */
    constructor(event) {
        super(event, EventType.ContractExpired);
        const [nftId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
    }
}
exports.ContractExpiredEvent = ContractExpiredEvent;
/**
 * This class represents the on-chain MarketplaceCreatedEvent event.
 */
class MarketplaceCreatedEvent extends BlockchainEvent {
    /**
     * Construct the data object from MarketplaceCreatedEvent event
     * @param event The MarketplaceCreatedEvent event
     */
    constructor(event) {
        super(event, EventType.MarketplaceCreated);
        this.marketplaceId = Number.parseInt(event.data[0].toString());
        this.owner = event.data[1].toString();
        this.kind = event.data[2].toString() == "Public" ? enum_1.MarketplaceKind.Public : enum_1.MarketplaceKind.Private;
    }
}
exports.MarketplaceCreatedEvent = MarketplaceCreatedEvent;
/**
 * This class represents the on-chain MarketplaceConfigSetEvent event.
 */
class MarketplaceConfigSetEvent extends BlockchainEvent {
    /**
     * Construct the data object from MarketplaceConfigSetEvent event
     * @param event The MarketplaceConfigSetEvent event
     */
    constructor(event) {
        super(event, EventType.MarketplaceConfigSet);
        const [marketplaceId, commissionFee, listingFee, accountList, offchainData, collectionList] = event.data;
        const isCommissionFeeSet = commissionFee.toString() !== "Noop" && commissionFee.toString() !== "Remove";
        const isCommissionFeeRemoved = commissionFee.toString() === "Remove";
        const isListingFeeSet = listingFee.toString() !== "Noop" && listingFee.toString() !== "Remove";
        const isListingFeeRemoved = listingFee.toString() === "Remove";
        const isAccountListSet = accountList.toString() !== "Noop" && accountList.toString() !== "Remove";
        const isAccountListRemoved = accountList.toString() === "Remove";
        const isOffchainDataSet = offchainData.toString() !== "Noop" && offchainData.toString() !== "Remove";
        const isOffchainDataRemoved = offchainData.toString() === "Remove";
        const isCollectionListSet = collectionList.toString() !== "Noop" && collectionList.toString() !== "Remove";
        const isCollectionListRemoved = collectionList.toString() === "Remove";
        this.marketplaceId = Number.parseInt(marketplaceId.toString());
        this.commissionFeeType = undefined;
        this.commissionFee = undefined;
        this.commissionFeeRounded = undefined;
        this.listingFeeType = undefined;
        this.listingFee = undefined;
        this.listingFeeRounded = undefined;
        this.accountList = undefined;
        this.offchainData = undefined;
        this.collectionList = undefined;
        if (isCommissionFeeSet) {
            const parsedDatas = JSON.parse(commissionFee.toString());
            parsedDatas.set.flat
                ? ((this.commissionFee = (0, util_1.bnToBn)(parsedDatas.set.flat).toString()),
                    (this.commissionFeeRounded = (0, utils_1.roundBalance)(this.commissionFee)),
                    (this.commissionFeeType = enum_1.MarketplaceConfigFeeType.Flat))
                : ((this.commissionFee = String(Number(parsedDatas.set.percentage.toString()) / 10000)),
                    (this.commissionFeeRounded = Number(this.commissionFee)),
                    (this.commissionFeeType = enum_1.MarketplaceConfigFeeType.Percentage));
        }
        else if (isCommissionFeeRemoved) {
            this.commissionFee = null;
            this.commissionFeeRounded = null;
            this.commissionFeeType = null;
        }
        if (isListingFeeSet) {
            const parsedDatas = JSON.parse(listingFee.toString());
            parsedDatas.set.flat
                ? ((this.listingFee = (0, util_1.bnToBn)(parsedDatas.set.flat).toString()),
                    (this.listingFeeRounded = (0, utils_1.roundBalance)(this.listingFee)),
                    (this.listingFeeType = enum_1.MarketplaceConfigFeeType.Flat))
                : ((this.listingFee = String(Number(parsedDatas.set.percentage.toString()) / 10000)),
                    (this.listingFeeRounded = Number(this.listingFee)),
                    (this.listingFeeType = enum_1.MarketplaceConfigFeeType.Percentage));
        }
        else if (isListingFeeRemoved) {
            this.listingFee = null;
            this.listingFeeRounded = null;
            this.listingFeeType = null;
        }
        if (isAccountListSet) {
            this.accountList = [];
            const parsedDatas = JSON.parse(accountList.toString());
            parsedDatas.set.map((account) => { var _a; return (_a = this.accountList) === null || _a === void 0 ? void 0 : _a.push(account.toString()); });
        }
        else if (isAccountListRemoved) {
            this.accountList = [];
        }
        if (isOffchainDataSet) {
            const parsedDatas = JSON.parse(offchainData.toString());
            this.offchainData = (0, util_1.hexToString)(parsedDatas.set.toString());
        }
        else if (isOffchainDataRemoved) {
            this.offchainData = null;
        }
        if (isCollectionListSet) {
            this.collectionList = [];
            const parsedDatas = JSON.parse(collectionList.toString());
            parsedDatas.set.map((collection) => { var _a; return (_a = this.collectionList) === null || _a === void 0 ? void 0 : _a.push(collection); });
        }
        else if (isCollectionListRemoved) {
            this.collectionList = [];
        }
    }
}
exports.MarketplaceConfigSetEvent = MarketplaceConfigSetEvent;
/**
 * This class represents the on-chain MarketplaceOwnerSetEvent event.
 */
class MarketplaceOwnerSetEvent extends BlockchainEvent {
    /**
     * Construct the data object from MarketplaceOwnerSetEvent event
     * @param event The MarketplaceOwnerSetEvent event
     */
    constructor(event) {
        super(event, EventType.MarketplaceOwnerSet);
        const [marketplaceId, owner] = event.data;
        this.marketplaceId = Number.parseInt(marketplaceId.toString());
        this.owner = owner.toString();
    }
}
exports.MarketplaceOwnerSetEvent = MarketplaceOwnerSetEvent;
/**
 * This class represents the on-chain MarketplaceKindSetEvent event.
 */
class MarketplaceKindSetEvent extends BlockchainEvent {
    /**
     * Construct the data object from MarketplaceKindSetEvent event
     * @param event The MarketplaceKindSetEvent event
     */
    constructor(event) {
        super(event, EventType.MarketplaceKindSet);
        const [marketplaceId, kind] = event.data;
        this.marketplaceId = Number.parseInt(marketplaceId.toString());
        this.kind = kind.toString() == "Public" ? enum_1.MarketplaceKind.Public : enum_1.MarketplaceKind.Private;
    }
}
exports.MarketplaceKindSetEvent = MarketplaceKindSetEvent;
/**
 * This class represents the on-chain MarketplaceMintFeeSetEvent event.
 */
class MarketplaceMintFeeSetEvent extends BlockchainEvent {
    /**
     * Construct the data object from MarketplaceMintFeeSetEvent event
     * @param event The MarketplaceMintFeeSetEvent event
     */
    constructor(event) {
        super(event, EventType.MarketplaceMintFeeSet);
        const [fee] = event.data;
        this.fee = fee.toString();
        this.feeRounded = (0, utils_1.roundBalance)(this.fee);
    }
}
exports.MarketplaceMintFeeSetEvent = MarketplaceMintFeeSetEvent;
/**
 * This class represents the on-chain NFTListedEvent event.
 */
class NFTListedEvent extends BlockchainEvent {
    /**
     * Construct the data object from NFTListedEvent event
     * @param event The NFTListedEvent event
     */
    constructor(event) {
        super(event, EventType.NFTListed);
        const [nftId, marketplaceId, price, commissionFee] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.marketplaceId = Number.parseInt(marketplaceId.toString());
        this.price = price.toString();
        this.priceRounded = (0, utils_1.roundBalance)(this.price);
        this.commissionFeeType = undefined;
        this.commissionFee = undefined;
        this.commissionFeeRounded = undefined;
        const parsedCommissionFee = commissionFee.toString() && JSON.parse(commissionFee.toString());
        const isMarketplaceCommissionFeeFlat = parsedCommissionFee && parsedCommissionFee.flat;
        const isMarketplaceCommissionFeePercentage = parsedCommissionFee && parsedCommissionFee.percentage;
        if (isMarketplaceCommissionFeeFlat) {
            this.commissionFeeType = enum_1.MarketplaceConfigFeeType.Flat;
            this.commissionFee = (0, util_1.bnToBn)(parsedCommissionFee.flat).toString();
            this.commissionFeeRounded = (0, utils_1.roundBalance)(this.commissionFee);
        }
        else if (isMarketplaceCommissionFeePercentage) {
            this.commissionFeeType = enum_1.MarketplaceConfigFeeType.Percentage;
            this.commissionFee = String(Number(parsedCommissionFee.percentage.toString()) / 10000);
            this.commissionFeeRounded = Number(this.commissionFee);
        }
    }
}
exports.NFTListedEvent = NFTListedEvent;
/**
 * This class represents the on-chain NFTUnlistedEvent event.
 */
class NFTUnlistedEvent extends BlockchainEvent {
    /**
     * Construct the data object from NFTUnlistedEvent event
     * @param event The NFTUnlistedEvent event
     */
    constructor(event) {
        super(event, EventType.NFTUnlisted);
        const [nftId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
    }
}
exports.NFTUnlistedEvent = NFTUnlistedEvent;
/**
 * This class represents the on-chain NFTSoldEvent event.
 */
class NFTSoldEvent extends BlockchainEvent {
    /**
     * Construct the data object from NFTSoldEvent event
     * @param event The NFTSoldEvent event
     */
    constructor(event) {
        super(event, EventType.NFTSold);
        const [nftId, marketplaceId, buyer, listedPrice, marketplaceCut, royaltyCut] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.marketplaceId = Number.parseInt(marketplaceId.toString());
        this.buyer = buyer.toString();
        this.listedPrice = listedPrice.toString();
        this.listedPriceRounded = (0, utils_1.roundBalance)(this.listedPrice);
        this.marketplaceCut = marketplaceCut.toString();
        this.marketplaceCutRounded = (0, utils_1.roundBalance)(this.marketplaceCut);
        this.royaltyCut = royaltyCut.toString();
        this.royaltyCutRounded = (0, utils_1.roundBalance)(this.royaltyCut);
    }
}
exports.NFTSoldEvent = NFTSoldEvent;
/**
 * This class represents the on-chain AuctionCreatedEvent event.
 */
class AuctionCreatedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the AuctionCreatedEvent event
     * @param event The AuctionCreatedEvent event
     */
    constructor(event) {
        super(event, EventType.AuctionCreated);
        const [nftId, marketplaceId, creator, startPrice, buyItPrice, startBlockId, endBlockId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.marketplaceId = Number.parseInt(marketplaceId.toString());
        this.creator = creator.toString();
        this.startPrice = startPrice.toString();
        this.startPriceRounded = (0, utils_1.roundBalance)(this.startPrice);
        this.buyItPrice = buyItPrice.toString();
        this.buyItPriceRounded = (0, utils_1.roundBalance)(this.buyItPrice);
        this.startBlock = Number.parseInt(startBlockId.toString());
        this.endBlock = Number.parseInt(endBlockId.toString());
    }
}
exports.AuctionCreatedEvent = AuctionCreatedEvent;
/**
 * This class represents the on-chain AuctionCancelledEvent event.
 */
class AuctionCancelledEvent extends BlockchainEvent {
    /**
     * Construct the data object from the AuctionCancelledEvent event
     * @param event The AuctionCancelledEvent event
     */
    constructor(event) {
        super(event, EventType.AuctionCancelled);
        const [nftId] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
    }
}
exports.AuctionCancelledEvent = AuctionCancelledEvent;
/**
 * This class represents the on-chain AuctionCompleted event.
 */
class AuctionCompletedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the AuctionCompleted event
     * @param event The AuctionCompleted event
     */
    constructor(event) {
        super(event, EventType.AuctionCompleted);
        const [nftId, newOwner, amount, marketplaceCut, royaltyCut] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.newOwner = newOwner.toString();
        this.amount = amount.toString();
        this.amountRounded = (0, utils_1.roundBalance)(this.amount);
        this.marketplaceCut = marketplaceCut.toString();
        this.marketplaceCutRounded = (0, utils_1.roundBalance)(this.marketplaceCut);
        this.royaltyCut = royaltyCut.toString();
        this.royaltyCutRounded = (0, utils_1.roundBalance)(this.royaltyCut);
    }
}
exports.AuctionCompletedEvent = AuctionCompletedEvent;
/**
 * This class represents the on-chain BidAdded event.
 */
class BidAddedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the BidAdded event
     * @param event The BidAdded event
     */
    constructor(event) {
        super(event, EventType.BidAdded);
        const [nftId, bidder, amount] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.bidder = bidder.toString();
        this.amount = amount.toString();
        this.amountRounded = (0, utils_1.roundBalance)(this.amount);
    }
}
exports.BidAddedEvent = BidAddedEvent;
/**
 * This class represents the on-chain BidRemoved event.
 */
class BidRemovedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the BidRemoved event
     * @param event The BidRemoved event
     */
    constructor(event) {
        super(event, EventType.BidRemoved);
        const [nftId, bidder, amount] = event.data;
        this.nftId = Number.parseInt(nftId.toString());
        this.bidder = bidder.toString();
        this.amount = amount.toString();
        this.amountRounded = (0, utils_1.roundBalance)(this.amount);
    }
}
exports.BidRemovedEvent = BidRemovedEvent;
/**
 * This class represents the on-chain BalanceClaimed event.
 */
class BalanceClaimedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the BalanceClaimed event
     * @param event The BalanceClaimed event
     */
    constructor(event) {
        super(event, EventType.BalanceClaimed);
        const [account, amount] = event.data;
        this.account = account.toString();
        this.amount = amount.toString();
        this.amountRounded = (0, utils_1.roundBalance)(this.amount);
    }
}
exports.BalanceClaimedEvent = BalanceClaimedEvent;
/**
 * This class represents the on-chain ItemCompletedEvent event,
 * when a single item within a Batch of dispatches has completed with no error.
 */
class ItemCompletedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ItemCompletedEvent event
     * @param event The ItemCompletedEvent event
     */
    constructor(event) {
        super(event, EventType.ItemCompleted);
        // This is an empty event.
    }
}
exports.ItemCompletedEvent = ItemCompletedEvent;
/**
 * This class represents the on-chain ItemFailedEvent event,
 * when a single item within a Batch of dispatches has completed with error. .
 */
class ItemFailedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ItemFailedEvent event
     * @param event The ItemFailedEvent event
     */
    constructor(event) {
        super(event, EventType.ItemFailed);
        const [error] = event.data;
        this.error = error.toJSON();
        const errorNumber = parseInt(this.error.module.error.slice(2, 4), 16); // parse firsts 2 bytes of dispatchError.module.error using 16 base to get the error number and error message from substrate registry.
        const { docs, name } = error.registry.findMetaError({
            index: new bn_js_1.default(this.error.module.index),
            error: new bn_js_1.default(errorNumber),
        });
        this.errorType = name;
        this.errorDetails = docs.join(" ");
    }
}
exports.ItemFailedEvent = ItemFailedEvent;
/**
 * This class represents the on-chain BatchInterruptedEvent event,
 * when a batch of dispatches did not complete fully.
 */
class BatchInterruptedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the BatchInterruptedEvent event
     * @param event The BatchInterruptedEvent event
     */
    constructor(event) {
        super(event, EventType.BatchInterrupted);
        const [index, dispatchError] = event.data;
        this.index = Number.parseInt(index.toString());
        this.dispatchError = dispatchError.toJSON();
        const errorNumber = parseInt(this.dispatchError.module.error.slice(2, 4), 16); // parse firsts 2 bytes of dipatchError.module.error using 16 base to get the error number and error message from substrate registry.
        const { docs, name } = dispatchError.registry.findMetaError({
            index: new bn_js_1.default(this.dispatchError.module.index),
            error: new bn_js_1.default(errorNumber),
        });
        this.errorType = name;
        this.details = docs.join(" ");
    }
}
exports.BatchInterruptedEvent = BatchInterruptedEvent;
/**
 * This class represents the on-chain BatchCompletedWithErrorsEvent event,
 * when a batch of dispatches completed but has errors.
 */
class BatchCompletedWithErrorsEvent extends BlockchainEvent {
    /**
     * Construct the data object from the BatchCompletedWithErrorsEvent event
     * @param event The BatchCompletedWithErrorsEvent event
     */
    constructor(event) {
        super(event, EventType.BatchCompletedWithErrors);
        // This is an empty event.
    }
}
exports.BatchCompletedWithErrorsEvent = BatchCompletedWithErrorsEvent;
/**
 * This class represents the on-chain BatchInterruptedEvent event,
 * when a batch of dispatches completed fully with no error.
 */
class BatchCompletedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the BatchCompletedEvent event
     * @param event The BatchCompletedEvent event
     */
    constructor(event) {
        super(event, EventType.BatchCompleted);
        // This is an empty event.
    }
}
exports.BatchCompletedEvent = BatchCompletedEvent;
/**
 * This class represents the on-chain ExtrinsicFailedEvent event,
 * when an extrinsic failed.
 */
class ExtrinsicFailedEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ExtrinsicFailedEvent event
     * @param event The ExtrinsicFailedEvent event
     */
    constructor(event) {
        super(event, EventType.ExtrinsicFailed);
        const [dispatchError, dispatchInfo] = event.data;
        this.dispatchError = dispatchError.toJSON();
        const errorNumber = parseInt(this.dispatchError.module.error.slice(2, 4), 16); // parse firsts 2 bytes of dispatchError.module.error using 16 base to get the error number and error message from substrate registery.
        const { docs, name } = dispatchError.registry.findMetaError({
            index: new bn_js_1.default(this.dispatchError.module.index),
            error: new bn_js_1.default(errorNumber),
        });
        this.errorType = name;
        this.details = docs.join(" ");
        this.dispatchInfo = dispatchInfo === null || dispatchInfo === void 0 ? void 0 : dispatchInfo.toJSON();
    }
}
exports.ExtrinsicFailedEvent = ExtrinsicFailedEvent;
/**
 * This class represents the on-chain ExtrinsicSuccessEvent event,
 * when an extrinsic completed successfully.
 */
class ExtrinsicSuccessEvent extends BlockchainEvent {
    /**
     * Construct the data object from the ExtrinsicSuccessEvent event
     * @param event The ExtrinsicSuccessEvent event
     */
    constructor(event) {
        super(event, EventType.ExtrinsicSuccess);
        const [dispatchInfo] = event.data;
        this.dispatchInfo = dispatchInfo.toJSON();
    }
}
exports.ExtrinsicSuccessEvent = ExtrinsicSuccessEvent;
/**
 * This class represents the on-chain NewAccountEvent event,
 * when a new account was created.
 */
class NewAccountEvent extends BlockchainEvent {
    /**
     * Construct the data object from the NewAccountEvent event
     * @param event The NewAccountEvent event
     */
    constructor(event) {
        super(event, EventType.NewAccount);
        const [account] = event.data;
        this.account = account.toString();
    }
}
exports.NewAccountEvent = NewAccountEvent;
/**
 * This class represents the on-chain UnknownEvent event,
 */
class UnknownEvent extends BlockchainEvent {
    /**
     * Construct the data object from UnknownEvent event
     * @param event The UnknownEvent event
     */
    constructor(event) {
        super(event, EventType.Unknown);
        // This is an empty event.
    }
}
exports.UnknownEvent = UnknownEvent;
class BlockchainEvents {
    constructor(events) {
        this.inner = events;
    }
    findEvents(ctor) {
        const events = this.inner.filter((event) => event instanceof ctor);
        return events;
    }
    findEvent(ctor) {
        const maybeEvent = this.inner.find((event) => event instanceof ctor);
        return maybeEvent ? maybeEvent : undefined;
    }
    findEventOrThrow(ctor) {
        const failedEvent = this.inner.find((event) => event.type == EventType.ExtrinsicFailed);
        const targetEvent = this.inner.find((event) => event instanceof ctor);
        if (failedEvent) {
            throw new Error(`${constants_1.Errors.EXTRINSIC_FAILED} : ${failedEvent.errorType} - ${failedEvent.details}`);
        }
        if (targetEvent == undefined) {
            throw new Error(constants_1.Errors.EVENT_NOT_FOUND);
        }
        return targetEvent;
    }
}
exports.BlockchainEvents = BlockchainEvents;
