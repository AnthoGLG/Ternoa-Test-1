"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.teeNFTReconciliation = exports.formatReconciliationIntervalPayload = exports.teeKeySharesRemove = exports.teeKeySharesRetrieve = exports.sharesAvailableOnTeeCluster = exports.teeKeySharesStore = exports.teePost = exports.formatRetrievePayload = exports.formatStorePayload = exports.getTeeEnclaveSharesAvailablility = exports.getTeeEnclavesBaseUrl = exports.getFirstPublicClusterAvailable = exports.getPublicsClusters = exports.getEnclavesQuote = exports.getEnclaveDataAndHealth = exports.populateEnclavesData = exports.getEnclaveHealthStatus = exports.combineKeyShares = exports.generateKeyShares = exports.SIGNER_BLOCK_VALIDITY = exports.RECONCILIATION_NFT_INTERVAL = exports.TEE_AVAILABLE_CAPSULE_NFT_KEYSHARE_ENDPOINT = exports.TEE_REMOVE_CAPSULE_NFT_KEYSHARE_ENDPOINT = exports.TEE_RETRIEVE_CAPSULE_NFT_ENDPOINT = exports.TEE_STORE_CAPSULE_NFT_ENDPOINT = exports.TEE_AVAILABLE_SECRET_NFT_KEYSHARE_ENDPOINT = exports.TEE_REMOVE_SECRET_NFT_KEYSHARE_ENDPOINT = exports.TEE_RETRIEVE_SECRET_NFT_ENDPOINT = exports.TEE_STORE_SECRET_NFT_ENDPOINT = exports.TEE_QUOTE_ENDPOINT = exports.TEE_HEALTH_ENDPOINT = exports.ENCLAVES_IN_CLUSTER = exports.SSSA_THRESHOLD = exports.SSSA_NUMSHARES = void 0;
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const sssa_js_1 = require("sssa-js");
const buffer_1 = require("buffer");
const util_1 = require("@polkadot/util");
const crypto_1 = require("crypto");
const crypto_2 = require("./crypto");
const http_1 = require("./http");
const utils_1 = require("./utils");
const tee_1 = require("../tee");
const constants_1 = require("../constants");
const blockchain_1 = require("../blockchain");
const balance_1 = require("../balance");
const bn_js_1 = require("bn.js");
exports.SSSA_NUMSHARES = 5;
exports.SSSA_THRESHOLD = 3;
exports.ENCLAVES_IN_CLUSTER = 5;
const TEE_STORE_STATUS_SUCCESS = "STORESUCCESS";
const TEE_RETRIEVE_STATUS_SUCCESS = "RETRIEVESUCCESS";
exports.TEE_HEALTH_ENDPOINT = "/api/health";
exports.TEE_QUOTE_ENDPOINT = "/api/quote";
exports.TEE_STORE_SECRET_NFT_ENDPOINT = "/api/secret-nft/store-keyshare";
exports.TEE_RETRIEVE_SECRET_NFT_ENDPOINT = "/api/secret-nft/retrieve-keyshare";
exports.TEE_REMOVE_SECRET_NFT_KEYSHARE_ENDPOINT = "/api/secret-nft/remove-keyshare";
const TEE_AVAILABLE_SECRET_NFT_KEYSHARE_ENDPOINT = (nftId) => `/api/secret-nft/is-keyshare-available/${nftId}`;
exports.TEE_AVAILABLE_SECRET_NFT_KEYSHARE_ENDPOINT = TEE_AVAILABLE_SECRET_NFT_KEYSHARE_ENDPOINT;
exports.TEE_STORE_CAPSULE_NFT_ENDPOINT = "/api/capsule-nft/set-keyshare";
exports.TEE_RETRIEVE_CAPSULE_NFT_ENDPOINT = "/api/capsule-nft/retrieve-keyshare";
exports.TEE_REMOVE_CAPSULE_NFT_KEYSHARE_ENDPOINT = "/api/capsule-nft/remove-keyshare";
const TEE_AVAILABLE_CAPSULE_NFT_KEYSHARE_ENDPOINT = (nftId) => `/api/capsule-nft/is-keyshare-available/${nftId}`;
exports.TEE_AVAILABLE_CAPSULE_NFT_KEYSHARE_ENDPOINT = TEE_AVAILABLE_CAPSULE_NFT_KEYSHARE_ENDPOINT;
exports.RECONCILIATION_NFT_INTERVAL = "/api/metric/interval-nft-list";
exports.SIGNER_BLOCK_VALIDITY = 15;
/**
 * @name generateKeyShares
 * @summary     Generates an array of shares from the incoming parameter string.
 * @param data  The data to split into shares (e.g. private key).
 * @returns     An array of stringified shares.
 */
const generateKeyShares = (data) => {
    const shares = (0, sssa_js_1.create)(exports.SSSA_THRESHOLD, exports.SSSA_NUMSHARES, data);
    const base64shares = shares.map((share) => buffer_1.Buffer.from(share).toString("base64"));
    return base64shares;
};
exports.generateKeyShares = generateKeyShares;
/**
 * @name combineKeyShares
 * @summary       Combines an array of shares to reconstruct data.
 * @param shares  Array of stringified shares.
 * @returns       The original data reconstructed.
 */
const combineKeyShares = (shares) => {
    const filteredShares = shares.filter((x) => x);
    if (filteredShares.length < exports.SSSA_THRESHOLD)
        throw new Error(`${constants_1.Errors.TEE_RETRIEVE_ERROR} - CANNOT_COMBINE_SHARES: expected a minimum of ${exports.SSSA_THRESHOLD} shares.`);
    const hexShares = filteredShares.map((bufferShare) => buffer_1.Buffer.from(bufferShare, "base64").toString("utf-8"));
    const combinedShares = (0, sssa_js_1.combine)(hexShares);
    return combinedShares;
};
exports.combineKeyShares = combineKeyShares;
/**
 * @name getEnclaveHealthStatus
 * @summary           Check that all TEE enclaves from a cluster are ready to be used.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of JSONs containing each enclave information (status, date, description, addresses)
 */
const getEnclaveHealthStatus = (clusterId = 0, timeout = 10000) => __awaiter(void 0, void 0, void 0, function* () {
    const teeEnclaves = yield (0, exports.getTeeEnclavesBaseUrl)(clusterId);
    const lastBlock = yield (0, crypto_2.getLastBlock)();
    const clusterHealthCheck = yield Promise.all(teeEnclaves.map((enclaveUrl, idx) => __awaiter(void 0, void 0, void 0, function* () {
        const http = new http_1.HttpClient((0, utils_1.ensureHttps)(enclaveUrl), timeout);
        const enclaveData = yield http.getRaw(exports.TEE_HEALTH_ENDPOINT);
        const isError = enclaveData.status !== 200;
        if (isError || !enclaveData.sync_state.length || enclaveData.sync_state == "setup")
            throw new Error(`${constants_1.Errors.TEE_ENCLAVE_NOT_AVAILBLE} - ID ${idx}, URL: ${enclaveUrl}. ${enclaveData.description}`);
        // ADDITIONAL CHECKS
        if ((lastBlock - enclaveData.block_number) > 4)
            throw new Error(`${constants_1.Errors.TEE_ENCLAVE_NOT_AVAILBLE} - ID ${idx}, URL: ${enclaveUrl}. Enclave blocks not synchornized with chain`);
        const { free } = yield (0, balance_1.getBalances)(enclaveData.enclave_address);
        const ONE_CAPS = new bn_js_1.BN("1000000000000000000");
        if (free.lt(ONE_CAPS))
            throw new Error(`${constants_1.Errors.TEE_ENCLAVE_NOT_AVAILBLE} - ID ${idx}, URL: ${enclaveUrl}. Enclave balance too low`);
        return enclaveData;
    })));
    return clusterHealthCheck;
});
exports.getEnclaveHealthStatus = getEnclaveHealthStatus;
/**
 * @name populateEnclavesData
 * @summary           Populate enclaves data with addresses, slot and urls.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of the TEE enclaves data for the cluster.
 */
const populateEnclavesData = (clusterId = 0) => __awaiter(void 0, void 0, void 0, function* () {
    const clusterData = yield (0, tee_1.getClusterData)(clusterId);
    if (!clusterData)
        throw new Error(constants_1.Errors.TEE_CLUSTER_NOT_FOUND);
    if (clusterData.enclaves.length === 0)
        throw new Error(`${constants_1.Errors.TEE_CLUSTER_IS_EMPTY}: ${clusterId}`);
    const data = yield Promise.all(clusterData.enclaves.map((enclave) => __awaiter(void 0, void 0, void 0, function* () {
        const enclaveData = yield (0, tee_1.getEnclaveData)(enclave[0]);
        if (!enclaveData)
            throw new Error(constants_1.Errors.TEE_ENCLAVE_NOT_FOUND);
        return {
            clusterId,
            clusterType: clusterData.clusterType,
            enclaveAddress: enclaveData.enclaveAddress,
            operatorAddress: enclave[0],
            enclaveUrl: (0, utils_1.removeURLSlash)((0, util_1.hexToString)(enclaveData.apiUri)),
            enclaveSlot: enclave[1],
        };
    })));
    return data;
});
exports.populateEnclavesData = populateEnclavesData;
/**
 * @name getEnclaveDataAndHealth
 * @summary           Get the enclaves data from a cluster populated with health check.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of JSONs containing each enclave data populated with its health information.
 */
const getEnclaveDataAndHealth = (clusterId = 0, timeout = 10000) => __awaiter(void 0, void 0, void 0, function* () {
    const teeEnclaves = yield (0, exports.populateEnclavesData)(clusterId);
    const enclaveData = yield Promise.all(teeEnclaves.map((e, idx) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const http = new http_1.HttpClient((0, utils_1.ensureHttps)(e.enclaveUrl), timeout);
            const enclaveHealthData = yield http.getRaw(exports.TEE_HEALTH_ENDPOINT);
            const { block_number, sync_state, version, description, status } = enclaveHealthData;
            return Object.assign(Object.assign({}, e), { status, blockNumber: block_number, syncState: sync_state, description, version });
        }
        catch (error) {
            const blockNumber = yield (0, crypto_2.getLastBlock)();
            const description = error instanceof Error ? `SGX_SERVER_ERROR - ${error.message}` : "SGX_SERVER_ERROR - ENCLAVE UNREACHABLE";
            return Object.assign(Object.assign({}, teeEnclaves[idx]), { status: 500, blockNumber, syncState: "Internal Error", description });
        }
    })));
    return enclaveData;
});
exports.getEnclaveDataAndHealth = getEnclaveDataAndHealth;
/**
 * @name getEnclavesQuote
 * @summary           Generate the enclaves quote.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of JSONs containing each enclave quote information (status, data or error)
 */
const getEnclavesQuote = (clusterId = 0) => __awaiter(void 0, void 0, void 0, function* () {
    const teeEnclaves = yield (0, exports.populateEnclavesData)(clusterId);
    const clusterQuote = yield Promise.all(teeEnclaves.map((e, idx) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const http = new http_1.HttpClient((0, utils_1.ensureHttps)(e.enclaveUrl));
            const enclaveData = yield http.getRaw(exports.TEE_QUOTE_ENDPOINT);
            const { status, data, block_number } = enclaveData;
            return Object.assign(Object.assign({}, e), { status, data, blockNumber: block_number });
        }
        catch (error) {
            const description = error instanceof Error
                ? `INTERNAL_SGX_SERVER_ERROR - ${error.message}`
                : `INTERNAL_SGX_SERVER_ERROR - QUOTE_NOT_AVAILABLE`;
            return Object.assign(Object.assign({}, teeEnclaves[idx]), { status: 500, data: description });
        }
    })));
    return clusterQuote;
});
exports.getEnclavesQuote = getEnclavesQuote;
/**
 * @name getPublicsClusters
 * @summary           Provides the list of the availables publics clusters.
 * @returns           An array of publics clusterId.
 */
const getPublicsClusters = () => __awaiter(void 0, void 0, void 0, function* () {
    const nextClusterId = yield (0, tee_1.getNextClusterIdAvailable)();
    const clustersList = [];
    for (let i = 0; i < nextClusterId; i++) {
        try {
            const data = yield (0, blockchain_1.query)(constants_1.txPallets.tee, constants_1.chainQuery.clusterData, [i]);
            const result = data.toJSON();
            if (result) {
                const { enclaves, clusterType } = result;
                // CHECK PUBLIC CLUSTERS WITH THE 5 ENCLAVES WORKING
                if (enclaves.length === exports.ENCLAVES_IN_CLUSTER && clusterType === "Public") {
                    clustersList.push(i);
                }
            }
        }
        catch (error) {
            // DO NOT THROW AN ERROR - WE WANT TO PROVIDE A LIST.
            // console.log(`CLUSTER_UNAVAILABLE: ${i} - ${error instanceof Error ? error.message : JSON.stringify(error)}`)
        }
    }
    return clustersList;
});
exports.getPublicsClusters = getPublicsClusters;
/**
 * @name getFirstPublicClusterAvailable
 * @summary           Provides the id of the first available healthy public cluster.
 * @returns           A clusterId as a number.
 */
const getFirstPublicClusterAvailable = (timeout = 10000) => __awaiter(void 0, void 0, void 0, function* () {
    const publicClusters = yield (0, exports.getPublicsClusters)();
    if (publicClusters.length === 0)
        return undefined;
    for (const cluster of publicClusters) {
        try {
            const healthData = yield (0, utils_1.timeoutTrigger)(() => (0, exports.getEnclaveHealthStatus)(cluster, timeout), timeout + 1000);
            if (healthData.length === exports.ENCLAVES_IN_CLUSTER) {
                return cluster;
            }
        }
        catch (error) {
            // DO NOT THROW AN ERROR - CONTINUE TO THE NEXT CLUSTER.
        }
    }
    return undefined;
});
exports.getFirstPublicClusterAvailable = getFirstPublicClusterAvailable;
/**
 * @name getTeeEnclavesBaseUrl
 * @summary           Retrieves the TEE enclaves urls stored on-chain.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of the TEE enclaves urls available.
 */
const getTeeEnclavesBaseUrl = (clusterId = 0) => __awaiter(void 0, void 0, void 0, function* () {
    const clusterData = yield (0, tee_1.getClusterData)(clusterId);
    if (!clusterData)
        throw new Error(constants_1.Errors.TEE_CLUSTER_NOT_FOUND);
    if (clusterData.enclaves.length === 0)
        throw new Error(`${constants_1.Errors.TEE_CLUSTER_IS_EMPTY}: ${clusterId}`);
    const urls = yield Promise.all(clusterData.enclaves.map((enclave) => __awaiter(void 0, void 0, void 0, function* () {
        const enclaveData = yield (0, tee_1.getEnclaveData)(enclave[0]);
        if (!enclaveData)
            throw new Error(constants_1.Errors.TEE_ENCLAVE_NOT_FOUND);
        return (0, utils_1.removeURLSlash)((0, util_1.hexToString)(enclaveData === null || enclaveData === void 0 ? void 0 : enclaveData.apiUri));
    })));
    return urls;
});
exports.getTeeEnclavesBaseUrl = getTeeEnclavesBaseUrl;
/**
 * @name getEnclaveSharesAvailablility
 * @summary           Check that an enclave from a cluster have registered a Capsule NFT or a Secret NFT's key shares
 * @param enclave     The enclave base url.
 * @param nftId       The Capsule NFT id or Secret NFT id to check key registration on enclave.
 * @param kind        The kind of NFT linked to the key being checked: "secret" or "capsule"
 * @returns           A JSON containing the enclave share availability (enclave_id, nft_id, an exists status (boolean))
 */
const getTeeEnclaveSharesAvailablility = (enclave, nftId, kind) => __awaiter(void 0, void 0, void 0, function* () {
    if (kind !== "secret" && kind !== "capsule") {
        throw new Error(`${constants_1.Errors.TEE_ERROR}: Kind must be either "secret" or "capsule"`);
    }
    const http = new http_1.HttpClient((0, utils_1.ensureHttps)(enclave));
    const endpoint = kind === "secret"
        ? (0, exports.TEE_AVAILABLE_SECRET_NFT_KEYSHARE_ENDPOINT)(nftId)
        : (0, exports.TEE_AVAILABLE_CAPSULE_NFT_KEYSHARE_ENDPOINT)(nftId);
    return yield http.get(endpoint);
});
exports.getTeeEnclaveSharesAvailablility = getTeeEnclaveSharesAvailablility;
/**
 * @name formatStorePayload
 * @summary                     Prepares post request payload to store secret/capsule NFT data into TEE enclaves.
 * @param ownerAddress          Address of the NFT's owner.
 * @param signerAuthMessage     The message to be signed by the owner to autenticate the tempory signer used to sign shares.
 * @param signerAuthSignature   The signerAuthMessage message signed by the NFT owner.
 * @param signerPair            The temporary signer account used to sign shares.
 * @param nftId                 The ID of the NFT.
 * @param share                 A share of the private key used to decrypt the NFT.
 * @param blockId               The current block header id on-chain.
 * @param blockValidity         A block duration validity for the temporay signer account to be valid; default SIGNER_BLOCK_VALIDITY = 100 blocks.
 * @returns                     Payload object ready to be submitted to TEE enclaves.
 */
const formatStorePayload = (ownerAddress, signerAuthMessage, signerAuthSignature, signerPair, nftId, share, blockId, blockValidity = exports.SIGNER_BLOCK_VALIDITY) => {
    const data = `<Bytes>${nftId}_${share}_${blockId}_${blockValidity}</Bytes>`;
    const dataSignature = (0, crypto_2.getSignatureFromKeyring)(signerPair, data);
    return {
        owner_address: ownerAddress,
        signer_address: signerAuthMessage,
        data,
        signature: dataSignature,
        signersig: signerAuthSignature,
    };
};
exports.formatStorePayload = formatStorePayload;
/**
 * @name formatRetrievePayload
 * @summary                  Prepares post request payload to retrieve secret/capsule NFT data into TEE enclaves.
 * @param requester          The NFT owner account (keyring) or address (string) used to sign data. It can also be the retriever account of rentee or delegatee.
 * @param requesterRole      Kind of account that want to retrieve the payload: it can be either "OWNER", "DELEGATEE" or "RENTEE"
 * @param nftId              The ID of the NFT.
 * @param blockId            The current block header id on-chain.
 * @param blockValidity      A block duration validity for the temporay signer account to be valid; default SIGNER_BLOCK_VALIDITY = 100 blocks.
 * @param extensionInjector  (Optional)The signer method retrived from your extension. We recommand Polkadot extention: object must have a signer key.
 * @returns                  Payload ready to be submitted to TEE enclaves.
 */
const formatRetrievePayload = (requester, requesterRole, nftId, blockId, blockValidity = exports.SIGNER_BLOCK_VALIDITY, extensionInjector) => __awaiter(void 0, void 0, void 0, function* () {
    if (typeof requester === "string" && !(0, blockchain_1.isValidAddress)(requester))
        throw new Error("INVALID_ADDRESS_FORMAT");
    if (typeof requester === "string" && !extensionInjector)
        throw new Error(`${constants_1.Errors.TEE_RETRIEVE_ERROR} - INJECTOR_SIGNER_MISSING : injectorSigner must be provided when signer is of type string`);
    const data = `<Bytes>${nftId}_${blockId}_${blockValidity}</Bytes>`;
    const signature = typeof requester === "string"
        ? extensionInjector && (yield (0, crypto_2.getSignatureFromExtension)(requester, extensionInjector, data))
        : (0, crypto_2.getSignatureFromKeyring)(requester, data);
    if (!signature)
        throw new Error(`${constants_1.Errors.TEE_RETRIEVE_ERROR} : cannot get signature when retrieving payload`);
    return {
        requester_address: typeof requester === "string" ? requester : requester.address,
        requester_type: requesterRole,
        data,
        signature,
    };
});
exports.formatRetrievePayload = formatRetrievePayload;
/**
 * @name teePost
 * @summary               Upload secret payload data to an TEE enclave.
 * @param http            HttpClient instance.
 * @param endpoint        TEE enclave endpoint.
 * @param secretPayload   Payload formatted with the required secret NFT's data.
 * @returns               TEE enclave response.
 */
const teePost = (http, endpoint, secretPayload) => __awaiter(void 0, void 0, void 0, function* () {
    const headers = {
        "Content-Type": "application/json",
    };
    return http.post(endpoint, secretPayload, {
        headers,
    });
});
exports.teePost = teePost;
/**
 * @name teeKeySharesStore
 * @summary               Upload secret shares to TEE enclaves with retry.
 * @param clusterId       The TEE Cluster id to upload shares to.
 * @param kind            The kind of nft linked to the key uploaded: "secret" or "capsule"
 * @param payloads        Array of payloads containing secret data and each share of the private key. Should contain *SSSA_NUMSHARES* payloads.
 * @param nbRetry         The number of retry that need to be proceeded in case of fail during a share upload. Default is 3.
 * @param enclavesIndex   Optional: An Array of enclaves index. For example, some enclaves that previously failed that need to be uploaded again.
 * @returns               TEE enclave response including both the payload and the enclave response.
 */
const teeKeySharesStore = (clusterId = 0, kind, payloads, nbRetry = 3, enclavesIndex) => __awaiter(void 0, void 0, void 0, function* () {
    if (kind !== "secret" && kind !== "capsule") {
        throw new Error(`${constants_1.Errors.TEE_UPLOAD_ERROR} : Kind must be either "secret" or "capsule"`);
    }
    const nbShares = enclavesIndex && enclavesIndex.length > 0 && enclavesIndex.length <= exports.SSSA_NUMSHARES
        ? enclavesIndex.length
        : exports.SSSA_NUMSHARES;
    if (payloads.length !== nbShares)
        throw new Error(`${constants_1.Errors.NOT_CORRECT_AMOUNT_TEE_PAYLOADS} - Got: ${payloads.length}; Expected: ${exports.SSSA_NUMSHARES}`);
    const teeEnclaves = yield (0, exports.populateEnclavesData)(clusterId);
    if (teeEnclaves.length !== exports.SSSA_NUMSHARES)
        throw new Error(`${constants_1.Errors.NOT_CORRECT_AMOUNT_TEE_ENCLAVES} - Got: ${teeEnclaves.length}; Expected: ${exports.SSSA_NUMSHARES}`);
    const teeRes = yield Promise.all(payloads.map((payload, idx) => __awaiter(void 0, void 0, void 0, function* () {
        const { enclaveUrl, enclaveAddress, operatorAddress, enclaveSlot } = teeEnclaves[enclavesIndex && enclavesIndex.length > 0 ? enclavesIndex[idx] : idx];
        const http = new http_1.HttpClient((0, utils_1.ensureHttps)(enclaveUrl));
        const endpoint = kind === "secret" ? exports.TEE_STORE_SECRET_NFT_ENDPOINT : exports.TEE_STORE_CAPSULE_NFT_ENDPOINT;
        const post = () => __awaiter(void 0, void 0, void 0, function* () { return yield (0, exports.teePost)(http, endpoint, payload); });
        const retryFn = yield (0, utils_1.retryPost)(post, nbRetry);
        return Object.assign({ enclaveAddress, operatorAddress, enclaveSlot }, retryFn);
    })));
    return teeRes.map((enclaveRes, i) => {
        const payload = payloads[i];
        if ("isRetryError" in enclaveRes) {
            const { message, status, enclaveAddress, operatorAddress, enclaveSlot } = enclaveRes;
            return Object.assign({ enclaveAddress,
                operatorAddress,
                enclaveSlot, description: message, nft_id: Number(payload.data.split("_")[0]), status: status, isError: true }, payload);
        }
        return Object.assign(Object.assign(Object.assign({}, enclaveRes), { isError: enclaveRes.status !== TEE_STORE_STATUS_SUCCESS }), payload);
    });
});
exports.teeKeySharesStore = teeKeySharesStore;
/**
 * @name sharesAvailableOnTeeCluster
 * @summary           Check that all enclaves from a cluster have registered a the Capsule NFT or a Secret NFT's key shares
 * @param clusterId   The TEE Cluster id.
 * @param nftId       The Capsule NFT id or Secret NFT id to check key registration on enclaves.
 * @param kind        The kind of NFT linked to the key being checked: "secret" or "capsule"
 * @returns           A boolean status indicating if enclaves have stored the NFT shares.
 */
const sharesAvailableOnTeeCluster = (clusterId = 0, nftId, kind) => __awaiter(void 0, void 0, void 0, function* () {
    if (kind !== "secret" && kind !== "capsule") {
        throw new Error(`${constants_1.Errors.TEE_ERROR}: Kind must be either "secret" or "capsule"`);
    }
    const teeEnclaves = yield (0, exports.getTeeEnclavesBaseUrl)(clusterId);
    let isShareAvailable = false;
    let i = 0;
    while (isShareAvailable !== true && i <= teeEnclaves.length - 1) {
        const { exists } = yield (0, exports.getTeeEnclaveSharesAvailablility)(teeEnclaves[i], nftId, kind);
        isShareAvailable = exists;
        i += 1;
    }
    return isShareAvailable;
});
exports.sharesAvailableOnTeeCluster = sharesAvailableOnTeeCluster;
/**
 * @name teeKeySharesRetrieve
 * @summary           Get secret data shares from TEE enclaves.
 * @param clusterId   The TEE Cluster id to upload shares to.
 * @param kind        The kind of nft linked to the key being retrieved: "secret" or "capsule"
 * @param payload     The payload containing secret NFT data, the keyring address and the signature. You can use our formatPayload() function.
 * @returns           TEE enclave response.
 */
const teeKeySharesRetrieve = (clusterId, kind, payload) => __awaiter(void 0, void 0, void 0, function* () {
    if (kind !== "secret" && kind !== "capsule") {
        throw new Error(`${constants_1.Errors.TEE_RETRIEVE_ERROR} : Kind must be either "secret" or "capsule"`);
    }
    const teeEnclaves = yield (0, exports.getTeeEnclavesBaseUrl)(clusterId);
    if (teeEnclaves.length !== exports.SSSA_NUMSHARES)
        throw new Error(`${constants_1.Errors.NOT_CORRECT_AMOUNT_TEE_ENCLAVES} - Got: ${teeEnclaves.length}; Expected: ${exports.SSSA_NUMSHARES}`);
    const errors = [];
    let shares = yield Promise.all(teeEnclaves.map((baseUrl) => __awaiter(void 0, void 0, void 0, function* () {
        const http = new http_1.HttpClient((0, utils_1.ensureHttps)(baseUrl));
        const endpoint = kind === "secret" ? exports.TEE_RETRIEVE_SECRET_NFT_ENDPOINT : exports.TEE_RETRIEVE_CAPSULE_NFT_ENDPOINT;
        try {
            const res = yield (0, exports.teePost)(http, endpoint, payload);
            if (res.status !== TEE_RETRIEVE_STATUS_SUCCESS)
                errors.push(res.description ? res.description.split(":")[1] : "Share could not be retrieved");
            return res.status === TEE_RETRIEVE_STATUS_SUCCESS && res.keyshare_data
                ? res.keyshare_data.split("_")[1]
                : undefined;
        }
        catch (_a) {
            errors.push("Enclave not available");
        }
    })));
    shares = shares.filter((x) => x !== undefined);
    if (shares.length < exports.SSSA_THRESHOLD) {
        throw new Error(`${constants_1.Errors.TEE_RETRIEVE_ERROR} - Shares could not be retrieved: ${errors[0]}`);
    }
    return shares;
});
exports.teeKeySharesRetrieve = teeKeySharesRetrieve;
/**
 * @name teeKeySharesRemove
 * @summary                 Remove the share of a burnt NFT from the enclaves.
 * @param clusterId         The TEE Cluster id to remove the shares of the burnt NFT.
 * @param kind              The kind of NFT linked to the key being deleted: "secret" or "capsule"
 * @param requesterAddress  The requester address who want to remove the NFT key share.
 * @param nftId             The burnt NFT id to remove the key.
 * @returns                 An array of JSONs containing the TEE enclave result (status (boolean), enclave_id, nft_id, description)
 */
const teeKeySharesRemove = (clusterId, kind, requesterAddress, nftId) => __awaiter(void 0, void 0, void 0, function* () {
    if (kind !== "secret" && kind !== "capsule") {
        throw new Error(`${constants_1.Errors.TEE_REMOVE_ERROR} : Kind must be either "secret" or "capsule"`);
    }
    const teeEnclaves = yield (0, exports.getTeeEnclavesBaseUrl)(clusterId);
    const payload = {
        requester_address: requesterAddress,
        nft_id: nftId,
    };
    const shares = yield Promise.all(teeEnclaves.map((baseUrl) => __awaiter(void 0, void 0, void 0, function* () {
        const http = new http_1.HttpClient((0, utils_1.ensureHttps)(baseUrl));
        const endpoint = kind === "secret" ? exports.TEE_REMOVE_SECRET_NFT_KEYSHARE_ENDPOINT : exports.TEE_REMOVE_CAPSULE_NFT_KEYSHARE_ENDPOINT;
        try {
            const res = yield (0, exports.teePost)(http, endpoint, payload);
            return res;
        }
        catch (_b) {
            return {
                status: constants_1.Errors.TEE_REMOVE_ERROR,
                nft_id: nftId,
                enclave_id: baseUrl,
                description: "Enclave not available",
            };
        }
    })));
    return shares;
});
exports.teeKeySharesRemove = teeKeySharesRemove;
/**
 * @name formatReconciliationIntervalPayload
 * @summary                       Prepares post request payload to reconciliate the list of secret/capsule NFT synced on a block interval period.
 * @param interval                The block number interval period: an array of the starting and ending block.
 * @param metricsServerKeyring    The metric server keyring.
 * @returns                       A formatted payload ready to be submitted to TEE enclaves.
 */
const formatReconciliationIntervalPayload = (interval, metricsServerKeyring) => __awaiter(void 0, void 0, void 0, function* () {
    const block_number = yield (0, crypto_2.getLastBlock)();
    const block_validation = exports.SIGNER_BLOCK_VALIDITY;
    const formattedInterval = JSON.stringify(interval);
    const data_hash = (0, crypto_1.createHash)("sha256").update(formattedInterval).digest("hex");
    const authenticationToken = JSON.stringify({
        block_number,
        block_validation,
        data_hash,
    });
    const signedToken = (0, crypto_2.getSignatureFromKeyring)(metricsServerKeyring, authenticationToken);
    return {
        metric_account: metricsServerKeyring.address,
        block_interval: formattedInterval,
        auth_token: authenticationToken,
        signature: signedToken,
    };
});
exports.formatReconciliationIntervalPayload = formatReconciliationIntervalPayload;
/**
 * @name teeNFTReconciliation
 * @summary                       Get a reconciliation list of secret/capsule NFT synced on a block interval period.
 * @param clusterId               The TEE Cluster id to query.
 * @param interval                The block number interval period: an array of the starting and ending block.
 * @param metricsServerKeyring    The metric server keyring.
 * @returns                       An array of JSONs containing the NFT list and the TEE addresses (operator & enclave)
 */
const teeNFTReconciliation = (clusterId, interval, metricsServerKeyring) => __awaiter(void 0, void 0, void 0, function* () {
    const payload = yield (0, exports.formatReconciliationIntervalPayload)(interval, metricsServerKeyring);
    if (!payload)
        throw new Error(constants_1.Errors.RECONCILIATION_PAYLOAD_UNDEFINED);
    const teeEnclaves = yield (0, exports.populateEnclavesData)(clusterId);
    if (teeEnclaves.length !== exports.SSSA_NUMSHARES)
        throw new Error(`${constants_1.Errors.NOT_CORRECT_AMOUNT_TEE_ENCLAVES} - Got: ${teeEnclaves.length}; Expected: ${exports.SSSA_NUMSHARES}`);
    const errors = [];
    let nftList = yield Promise.all(teeEnclaves.map((e) => __awaiter(void 0, void 0, void 0, function* () {
        const http = new http_1.HttpClient((0, utils_1.ensureHttps)(e.enclaveUrl));
        try {
            const data = yield (0, exports.teePost)(http, exports.RECONCILIATION_NFT_INTERVAL, payload);
            return {
                enclaveAddress: e.enclaveAddress,
                operatorAddress: e.operatorAddress,
                nftId: data.nftid,
            };
        }
        catch (error) {
            const errorDescription = error instanceof Error ? error.message : JSON.stringify(error);
            errors.push({
                enclaveAddress: e.enclaveAddress,
                operatorAddress: e.operatorAddress,
                nftId: [],
                error: errorDescription,
            });
        }
    })));
    if (!nftList)
        throw new Error(constants_1.Errors.NFT_RECONCILIATION_FAILED);
    nftList = nftList.filter((x) => x !== undefined);
    return [...nftList, ...errors];
});
exports.teeNFTReconciliation = teeNFTReconciliation;
