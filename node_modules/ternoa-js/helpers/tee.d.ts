import { IKeyringPair } from "@polkadot/types/types";
import { HttpClient } from "./http";
import { RetrievePayloadType, StorePayloadType, TeeGenericDataResponseType, TeeSharesStoreType, RequesterType, ReconciliationPayloadType, TeeReconciliationType } from "./types";
import { EnclaveDataAndHealthType, EnclaveQuoteType, EnclaveHealthType, NFTShareAvailableType, PopulatedEnclavesDataType } from "../tee/types";
export declare const SSSA_NUMSHARES = 5;
export declare const SSSA_THRESHOLD = 3;
export declare const ENCLAVES_IN_CLUSTER = 5;
export declare const TEE_HEALTH_ENDPOINT = "/api/health";
export declare const TEE_QUOTE_ENDPOINT = "/api/quote";
export declare const TEE_STORE_SECRET_NFT_ENDPOINT = "/api/secret-nft/store-keyshare";
export declare const TEE_RETRIEVE_SECRET_NFT_ENDPOINT = "/api/secret-nft/retrieve-keyshare";
export declare const TEE_REMOVE_SECRET_NFT_KEYSHARE_ENDPOINT = "/api/secret-nft/remove-keyshare";
export declare const TEE_AVAILABLE_SECRET_NFT_KEYSHARE_ENDPOINT: (nftId: number) => string;
export declare const TEE_STORE_CAPSULE_NFT_ENDPOINT = "/api/capsule-nft/set-keyshare";
export declare const TEE_RETRIEVE_CAPSULE_NFT_ENDPOINT = "/api/capsule-nft/retrieve-keyshare";
export declare const TEE_REMOVE_CAPSULE_NFT_KEYSHARE_ENDPOINT = "/api/capsule-nft/remove-keyshare";
export declare const TEE_AVAILABLE_CAPSULE_NFT_KEYSHARE_ENDPOINT: (nftId: number) => string;
export declare const RECONCILIATION_NFT_INTERVAL = "/api/metric/interval-nft-list";
export declare const SIGNER_BLOCK_VALIDITY = 15;
/**
 * @name generateKeyShares
 * @summary     Generates an array of shares from the incoming parameter string.
 * @param data  The data to split into shares (e.g. private key).
 * @returns     An array of stringified shares.
 */
export declare const generateKeyShares: (data: string) => string[];
/**
 * @name combineKeyShares
 * @summary       Combines an array of shares to reconstruct data.
 * @param shares  Array of stringified shares.
 * @returns       The original data reconstructed.
 */
export declare const combineKeyShares: (shares: string[]) => string;
/**
 * @name getEnclaveHealthStatus
 * @summary           Check that all TEE enclaves from a cluster are ready to be used.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of JSONs containing each enclave information (status, date, description, addresses)
 */
export declare const getEnclaveHealthStatus: (clusterId?: number, timeout?: number) => Promise<EnclaveHealthType[]>;
/**
 * @name populateEnclavesData
 * @summary           Populate enclaves data with addresses, slot and urls.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of the TEE enclaves data for the cluster.
 */
export declare const populateEnclavesData: (clusterId?: number) => Promise<PopulatedEnclavesDataType[]>;
/**
 * @name getEnclaveDataAndHealth
 * @summary           Get the enclaves data from a cluster populated with health check.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of JSONs containing each enclave data populated with its health information.
 */
export declare const getEnclaveDataAndHealth: (clusterId?: number, timeout?: number) => Promise<EnclaveDataAndHealthType[]>;
/**
 * @name getEnclavesQuote
 * @summary           Generate the enclaves quote.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of JSONs containing each enclave quote information (status, data or error)
 */
export declare const getEnclavesQuote: (clusterId?: number) => Promise<EnclaveQuoteType[]>;
/**
 * @name getPublicsClusters
 * @summary           Provides the list of the availables publics clusters.
 * @returns           An array of publics clusterId.
 */
export declare const getPublicsClusters: () => Promise<number[]>;
/**
 * @name getFirstPublicClusterAvailable
 * @summary           Provides the id of the first available healthy public cluster.
 * @returns           A clusterId as a number.
 */
export declare const getFirstPublicClusterAvailable: (timeout?: number) => Promise<number | undefined>;
/**
 * @name getTeeEnclavesBaseUrl
 * @summary           Retrieves the TEE enclaves urls stored on-chain.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of the TEE enclaves urls available.
 */
export declare const getTeeEnclavesBaseUrl: (clusterId?: number) => Promise<string[]>;
/**
 * @name getEnclaveSharesAvailablility
 * @summary           Check that an enclave from a cluster have registered a Capsule NFT or a Secret NFT's key shares
 * @param enclave     The enclave base url.
 * @param nftId       The Capsule NFT id or Secret NFT id to check key registration on enclave.
 * @param kind        The kind of NFT linked to the key being checked: "secret" or "capsule"
 * @returns           A JSON containing the enclave share availability (enclave_id, nft_id, an exists status (boolean))
 */
export declare const getTeeEnclaveSharesAvailablility: (enclave: string, nftId: number, kind: "secret" | "capsule") => Promise<NFTShareAvailableType>;
/**
 * @name formatStorePayload
 * @summary                     Prepares post request payload to store secret/capsule NFT data into TEE enclaves.
 * @param ownerAddress          Address of the NFT's owner.
 * @param signerAuthMessage     The message to be signed by the owner to autenticate the tempory signer used to sign shares.
 * @param signerAuthSignature   The signerAuthMessage message signed by the NFT owner.
 * @param signerPair            The temporary signer account used to sign shares.
 * @param nftId                 The ID of the NFT.
 * @param share                 A share of the private key used to decrypt the NFT.
 * @param blockId               The current block header id on-chain.
 * @param blockValidity         A block duration validity for the temporay signer account to be valid; default SIGNER_BLOCK_VALIDITY = 100 blocks.
 * @returns                     Payload object ready to be submitted to TEE enclaves.
 */
export declare const formatStorePayload: (ownerAddress: string, signerAuthMessage: string, signerAuthSignature: string, signerPair: IKeyringPair, nftId: number, share: string, blockId: number, blockValidity?: number) => StorePayloadType;
/**
 * @name formatRetrievePayload
 * @summary                  Prepares post request payload to retrieve secret/capsule NFT data into TEE enclaves.
 * @param requester          The NFT owner account (keyring) or address (string) used to sign data. It can also be the retriever account of rentee or delegatee.
 * @param requesterRole      Kind of account that want to retrieve the payload: it can be either "OWNER", "DELEGATEE" or "RENTEE"
 * @param nftId              The ID of the NFT.
 * @param blockId            The current block header id on-chain.
 * @param blockValidity      A block duration validity for the temporay signer account to be valid; default SIGNER_BLOCK_VALIDITY = 100 blocks.
 * @param extensionInjector  (Optional)The signer method retrived from your extension. We recommand Polkadot extention: object must have a signer key.
 * @returns                  Payload ready to be submitted to TEE enclaves.
 */
export declare const formatRetrievePayload: (requester: IKeyringPair | string, requesterRole: RequesterType, nftId: number, blockId: number, blockValidity?: number, extensionInjector?: Record<string, any>) => Promise<RetrievePayloadType>;
/**
 * @name teePost
 * @summary               Upload secret payload data to an TEE enclave.
 * @param http            HttpClient instance.
 * @param endpoint        TEE enclave endpoint.
 * @param secretPayload   Payload formatted with the required secret NFT's data.
 * @returns               TEE enclave response.
 */
export declare const teePost: <T, K>(http: HttpClient, endpoint: string, secretPayload: T) => Promise<K>;
/**
 * @name teeKeySharesStore
 * @summary               Upload secret shares to TEE enclaves with retry.
 * @param clusterId       The TEE Cluster id to upload shares to.
 * @param kind            The kind of nft linked to the key uploaded: "secret" or "capsule"
 * @param payloads        Array of payloads containing secret data and each share of the private key. Should contain *SSSA_NUMSHARES* payloads.
 * @param nbRetry         The number of retry that need to be proceeded in case of fail during a share upload. Default is 3.
 * @param enclavesIndex   Optional: An Array of enclaves index. For example, some enclaves that previously failed that need to be uploaded again.
 * @returns               TEE enclave response including both the payload and the enclave response.
 */
export declare const teeKeySharesStore: (clusterId: number | undefined, kind: "secret" | "capsule", payloads: StorePayloadType[], nbRetry?: number, enclavesIndex?: number[]) => Promise<TeeSharesStoreType[]>;
/**
 * @name sharesAvailableOnTeeCluster
 * @summary           Check that all enclaves from a cluster have registered a the Capsule NFT or a Secret NFT's key shares
 * @param clusterId   The TEE Cluster id.
 * @param nftId       The Capsule NFT id or Secret NFT id to check key registration on enclaves.
 * @param kind        The kind of NFT linked to the key being checked: "secret" or "capsule"
 * @returns           A boolean status indicating if enclaves have stored the NFT shares.
 */
export declare const sharesAvailableOnTeeCluster: (clusterId: number | undefined, nftId: number, kind: "secret" | "capsule") => Promise<boolean>;
/**
 * @name teeKeySharesRetrieve
 * @summary           Get secret data shares from TEE enclaves.
 * @param clusterId   The TEE Cluster id to upload shares to.
 * @param kind        The kind of nft linked to the key being retrieved: "secret" or "capsule"
 * @param payload     The payload containing secret NFT data, the keyring address and the signature. You can use our formatPayload() function.
 * @returns           TEE enclave response.
 */
export declare const teeKeySharesRetrieve: (clusterId: number, kind: "secret" | "capsule", payload: RetrievePayloadType) => Promise<string[]>;
/**
 * @name teeKeySharesRemove
 * @summary                 Remove the share of a burnt NFT from the enclaves.
 * @param clusterId         The TEE Cluster id to remove the shares of the burnt NFT.
 * @param kind              The kind of NFT linked to the key being deleted: "secret" or "capsule"
 * @param requesterAddress  The requester address who want to remove the NFT key share.
 * @param nftId             The burnt NFT id to remove the key.
 * @returns                 An array of JSONs containing the TEE enclave result (status (boolean), enclave_id, nft_id, description)
 */
export declare const teeKeySharesRemove: (clusterId: number, kind: "secret" | "capsule", requesterAddress: string, nftId: number) => Promise<TeeGenericDataResponseType[]>;
/**
 * @name formatReconciliationIntervalPayload
 * @summary                       Prepares post request payload to reconciliate the list of secret/capsule NFT synced on a block interval period.
 * @param interval                The block number interval period: an array of the starting and ending block.
 * @param metricsServerKeyring    The metric server keyring.
 * @returns                       A formatted payload ready to be submitted to TEE enclaves.
 */
export declare const formatReconciliationIntervalPayload: (interval: [number, number], metricsServerKeyring: IKeyringPair) => Promise<ReconciliationPayloadType>;
/**
 * @name teeNFTReconciliation
 * @summary                       Get a reconciliation list of secret/capsule NFT synced on a block interval period.
 * @param clusterId               The TEE Cluster id to query.
 * @param interval                The block number interval period: an array of the starting and ending block.
 * @param metricsServerKeyring    The metric server keyring.
 * @returns                       An array of JSONs containing the NFT list and the TEE addresses (operator & enclave)
 */
export declare const teeNFTReconciliation: (clusterId: number, interval: [number, number], metricsServerKeyring: IKeyringPair) => Promise<(TeeReconciliationType | undefined)[]>;
