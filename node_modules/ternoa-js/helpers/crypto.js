"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLastBlock = exports.getSignatureFromExtension = exports.getSignatureFromKeyring = void 0;
const util_1 = require("@polkadot/util");
const blockchain_1 = require("../blockchain");
const buffer_1 = require("buffer");
/**
 * @name getSignatureFromKeyring
 * @summary         Signs data using the keyring.
 * @param keyring   Account that will sign the data.
 * @param data      Data to be signed.
 * @returns         Hex value of the signed data.
 */
const getSignatureFromKeyring = (keyring, data) => {
    const finalData = new Uint8Array(buffer_1.Buffer.from(data));
    return (0, util_1.u8aToHex)(keyring.sign(finalData));
};
exports.getSignatureFromKeyring = getSignatureFromKeyring;
/**
 * @name getSignatureFromExtension
 * @summary                 Signs data using an injector extension. We recommand Polkadot extention.
 * @param signerAddress     Account address that will sign the data.
 * @param injectorExtension The signer method retrived from your extension: object must have a signer key.
 * @param data              Data to be signed.
 * @returns                 Hex value of the signed data.
 */
const getSignatureFromExtension = (signerAddress, injectorExtension, data) => __awaiter(void 0, void 0, void 0, function* () {
    // To handle Polkadot Extension
    if (injectorExtension && "signer" in injectorExtension && injectorExtension.signer.signRaw) {
        const { signature } = (yield injectorExtension.signer.signRaw({
            address: signerAddress,
            data,
            type: "payload",
        }));
        return signature;
    }
    // To handle signing from Api
    else if (injectorExtension && "signer" in injectorExtension) {
        const api = (0, blockchain_1.getRawApi)();
        return yield api.sign(signerAddress, {
            data: data,
        }, { signer: injectorExtension.signer });
    }
});
exports.getSignatureFromExtension = getSignatureFromExtension;
/**
 * @name getLastBlock
 * @summary         Retrieve the last block number.
 * @returns         The last Block id (a number).
 */
const getLastBlock = () => __awaiter(void 0, void 0, void 0, function* () {
    const api = (0, blockchain_1.getRawApi)();
    const lastBlockHash = yield api.rpc.chain.getFinalizedHead();
    const lastBlock = yield api.rpc.chain.getBlock(lastBlockHash);
    const lastBlockId = Number(lastBlock.block.header.number.toString());
    return lastBlockId;
});
exports.getLastBlock = getLastBlock;
