/// <reference types="node" />
import { File, FormData } from "formdata-node";
import { IpfsAddDataResponseType, IServiceIPFS, CollectionMetadataType, NftMetadataType, MarketplaceMetadataType, CapsuleMedia, MediaMetadataType } from "./types";
/**
 * @implements {IServiceIPFS}
 */
export declare class TernoaIPFS {
    apiKey?: string;
    apiUrl: URL;
    constructor(apiUrl?: import("url").URL, apiKey?: string);
    /**
     * Get file from IPFS.
     *
     * @param ternoaIpfsService
     * @param hash
     * @returns IPFS file
     */
    static get: ({ apiUrl }: IServiceIPFS, hash: string) => Promise<unknown>;
    /**
     * Upload file form data to IPFS.
     *
     * @param service
     * @param form
     * @returns IPFS data (hash, size, name)
     */
    static upload: ({ apiKey, apiUrl }: IServiceIPFS, form: FormData) => Promise<IpfsAddDataResponseType>;
    /**
     * Store a single file on IPFS.
     *
     * @param service
     * @param file
     * @returns IPFS data (hash, size, name)
     */
    static storeFile: (service: IServiceIPFS, file: File) => Promise<IpfsAddDataResponseType>;
    /**
     * Store a Ternoa basic NFT's metadata & asset on IPFS.
     *
     * @param service
     * @param file      NFT's asset
     * @param metadata  Ternoa basic NFT metadata structure {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-100-Basic-NFT.md#metadata here}.
     * @returns         IPFS data (Hash, Size, Name)
     */
    static storeNFT: (service: IServiceIPFS, file: File, metadata: NftMetadataType) => Promise<IpfsAddDataResponseType>;
    /**
     * Store a Ternoa secret NFT's metadata & asset on IPFS.
     *
     * @param service
     * @param encryptedFile     NFT's encrypted asset.
     * @param encryptedFileType The original encrypted file type.
     * @param publicKey         Public key used to encrypt the Secret NFT.
     * @param nftMetadata       (Optional) Secret NFT metadata {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-520-Secret-nft.md here}.
     * @param mediaMetadata     (Optional) Secret NFT asset metadata.
     * @returns                 IPFS secret NFT data (Hash, Size, Name).
     */
    static storeSecretNFT: (service: IServiceIPFS, encryptedFile: string, encryptedFileType: string, publicKey: string, nftMetadata?: Partial<NftMetadataType>, mediaMetadata?: MediaMetadataType) => Promise<IpfsAddDataResponseType>;
    /**
     * Store a Ternoa Capsule NFT's metadata & assets on IPFS.
     *
     * @param service
     * @param publicKey         Public key used to encrypt the Capsule NFT.
     * @param encryptedMedia    An array of NFT's encrypted asset.
     * @param nftMetadata       (Optional) Capsule NFT metadata {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-530-Capsule.md here}.
     * @returns                 IPFS Capsule data (Hash, Size, Name).
     */
    static storeCapsuleNFT: (service: IServiceIPFS, publicKey: string, encryptedMedia: CapsuleMedia[], nftMetadata?: Partial<NftMetadataType>) => Promise<IpfsAddDataResponseType>;
    /**
     * Store a single Ternoa Collection's metadata & assets on IPFS.
     *
     * @param service
     * @param profileFile   Collection's profile asset
     * @param bannerFile    Collection's banner asset
     * @param metadata      Ternoa Collection metadata structure {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-101-Collection.md#metadata here}.
     * @returns             IPFS data (Hash, Size, Name)
     */
    static storeCollection: (service: IServiceIPFS, profileFile: File, bannerFile: File, metadata: CollectionMetadataType) => Promise<IpfsAddDataResponseType>;
    /**
     * Store a single Ternoa Marketplace's metadata & asset on IPFS.
     *
     * @param service
     * @param file      Marketplace's logo asset
     * @param metadata  Ternoa Marketplace metadata structure {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-200-Marketplace.md#metadata here}.
     * @returns         IPFS data (Hash, Size, Name)
     */
    static storeMarketplace: (service: IServiceIPFS, file: File, metadata: MarketplaceMetadataType) => Promise<IpfsAddDataResponseType>;
    getFile(hash: string): Promise<unknown>;
    storeFile(file: File): Promise<IpfsAddDataResponseType>;
    storeNFT(file: File, metadata: NftMetadataType): Promise<IpfsAddDataResponseType>;
    storeSecretNFT(encryptedFile: string, encryptedFileType: string, publicKey: string, nftMetadata?: Partial<NftMetadataType>, mediaMetadata?: MediaMetadataType): Promise<IpfsAddDataResponseType>;
    storeCapsuleNFT(publicKey: string, encryptedMedia: CapsuleMedia[], nftMetadata?: Partial<NftMetadataType>): Promise<IpfsAddDataResponseType>;
    storeCollection(profileFile: File, bannerFile: File, metadata: CollectionMetadataType): Promise<IpfsAddDataResponseType>;
    storeMarketplace(file: File, metadata: MarketplaceMetadataType): Promise<IpfsAddDataResponseType>;
}
export declare const validateNFTMetadata: ({ title, description }: NftMetadataType) => void;
export declare const validateOptionalNFTMetadata: ({ title, description }: Partial<NftMetadataType>) => void;
export declare const validateCollectionMetadata: ({ name, description }: CollectionMetadataType) => void;
export declare const validateMarketplaceMetadata: ({ name }: MarketplaceMetadataType) => void;
