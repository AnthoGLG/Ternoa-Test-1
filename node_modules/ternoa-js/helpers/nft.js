"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCapsuleNFTPrivateKey = exports.mintCapsuleNFT = exports.viewSecretNFT = exports.mintSecretNFT = exports.prepareAndStoreKeyShares = exports.getTemporarySignerKeys = exports.secretNftEncryptAndUploadFile = void 0;
const util_crypto_1 = require("@polkadot/util-crypto");
const encryption_1 = require("./encryption");
const tee_1 = require("./tee");
const crypto_1 = require("./crypto");
const account_1 = require("../account");
const constants_1 = require("../constants");
const nft_1 = require("../nft");
const blockchain_1 = require("../blockchain");
/**
 * @name secretNftEncryptAndUploadFile
 * @summary                 Encrypts and uploads a file on an IFPS gateway.
 * @param file              File to encrypt and then upload on IPFS.
 * @param publicPGPKey      Public Key to encrypt the file.
 * @param ipfsClient        A TernoaIPFS instance.
 * @param nftMetadata       Optional secret NFT metadata (Title, Description, (...)) {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-510-Secret-nft.md here}.
 * @param mediaMetadata     Optional asset NFT metadata (Name, Description, (...)) {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-510-Secret-nft.md here}.
 * @returns                 The data object with the secret NFT IPFS hash (ex: to add as offchain secret metadatas in the extrinsic).
 */
const secretNftEncryptAndUploadFile = (file, publicPGPKey, ipfsClient, nftMetadata, mediaMetadata) => __awaiter(void 0, void 0, void 0, function* () {
    if (!file)
        throw new Error(`${constants_1.Errors.IPFS_FILE_UPLOAD_ERROR} - File undefined`);
    const encryptedFile = yield (0, encryption_1.encryptFile)(file, publicPGPKey);
    const ipfsRes = yield ipfsClient.storeSecretNFT(encryptedFile, file.type, publicPGPKey, nftMetadata, mediaMetadata);
    return ipfsRes;
});
exports.secretNftEncryptAndUploadFile = secretNftEncryptAndUploadFile;
/**
 * @name getTemporarySignerKeys
 * @summary                 Generates a temporary signer account with soft-derivation
 * @param address           The owner address
 * @param lastBlockId       The last chain block number: Use our asyncronous getLastBlock() helper.
 * @returns                 A temporary signing key pair.
 */
const getTemporarySignerKeys = (address, lastBlockId) => __awaiter(void 0, void 0, void 0, function* () {
    const tmpSignerMnemonic = (0, util_crypto_1.mnemonicGenerate)();
    const tmpSignerPair = yield (0, account_1.getKeyringFromSeed)(tmpSignerMnemonic, undefined, `${lastBlockId}_${address}`);
    return tmpSignerPair;
});
exports.getTemporarySignerKeys = getTemporarySignerKeys;
/**
 * @name prepareAndStoreKeyShares
 * @summary                  Splits the private key into shards, format and send them for upload on to a Tee Cluster.
 * @param privateKey         The private key to be splited with Shamir algorithm.
 * @param signer             Account owner of the private key to split (keyring) or address (string) .
 * @param nftId              The Capsule NFT id or Secret NFT id to link to the private key.
 * @param kind               The kind of nft linked to the key to upload: "secret" or "capsule".
 * @param extensionInjector  (Optional)The signer method retrived from your extension to sign the transaction. We recommand Polkadot extention: object must have a signer key.
 * @param clusterId          (Optional)The TEE Cluster id. Default is set to cluster id 0.
 * @returns                  The TEE enclave response (shards datas and description).
 */
const prepareAndStoreKeyShares = (privateKey, signer, nftId, kind, extensionInjector, clusterId = 0) => __awaiter(void 0, void 0, void 0, function* () {
    if (kind !== "secret" && kind !== "capsule") {
        throw new Error(`${constants_1.Errors.TEE_UPLOAD_ERROR} : Kind must be either "secret" or "capsule"`);
    }
    if (typeof signer === "string" && !extensionInjector)
        throw new Error(`${constants_1.Errors.TEE_UPLOAD_ERROR} - INJECTOR_SIGNER_MISSING : injectorSigner must be provided when signer is of type string`);
    if (typeof signer === "string" && !(0, blockchain_1.isValidAddress)(signer))
        throw new Error("INVALID_ADDRESS_FORMAT");
    // 0. retrieve last chain block number and generate a temporary signer account with soft-derivation
    const lastBlockId = yield (0, crypto_1.getLastBlock)();
    const tmpSignerPair = yield (0, exports.getTemporarySignerKeys)(typeof signer === "string" ? signer : signer.address, lastBlockId);
    // 1. generate secret shares from the private key
    const shares = (0, tee_1.generateKeyShares)(privateKey);
    // 2. format payloads with temporary signer account
    const signerAddress = typeof signer === "string" ? signer : signer.address;
    const authMessage = `<Bytes>${tmpSignerPair.address}_${lastBlockId}_${tee_1.SIGNER_BLOCK_VALIDITY}</Bytes>`;
    const authSignature = typeof signer === "string"
        ? extensionInjector && (yield (0, crypto_1.getSignatureFromExtension)(signer, extensionInjector, authMessage))
        : (0, crypto_1.getSignatureFromKeyring)(signer, authMessage);
    if (!authSignature)
        throw new Error(`${constants_1.Errors.TEE_UPLOAD_ERROR} : signing of the temporary authentication message failed when uploading payload`);
    const payloads = yield Promise.all(shares.map((share) => (0, tee_1.formatStorePayload)(signerAddress, authMessage, authSignature, tmpSignerPair, nftId, share, lastBlockId)));
    // 3. request to store a batch of secret shares to the enclave
    return yield (0, tee_1.teeKeySharesStore)(clusterId, kind, payloads);
});
exports.prepareAndStoreKeyShares = prepareAndStoreKeyShares;
/**
 * @name mintSecretNFT
 * @summary                  Encrypts your data to create a secret NFT on-chain and uploads your key's shards on a TEE.
 * @param nftFile            File to upload as the preview of the encrypted NFT.
 * @param nftMetadata        NFT metadata (Title, Description).
 * @param secretNftFile      File to encrypt and then upload on IPFS.
 * @param secretNftMetadata  Secret NFT metadata (Title, Description).
 * @param ipfsClient         A TernoaIPFS instance.
 * @param ownerPair          Account of the secret NFT's owner.
 * @param clusterId          The TEE Cluster id. Default is set to cluster id 0.
 * @param royalty            Percentage of all second sales that the secret NFT creator will receive. Default is 0%. It's a decimal number in range [0, 100].
 * @param collectionId       The collection to which the secret NFT belongs. Optional Parameter: Default is undefined.
 * @param isSoulbound        If true, makes the secret NFT intransferable. Default is false.
 * @param waitUntil          Execution trigger that can be set either to BlockInclusion or BlockFinalization. Default is BlockInclusion.
 * @returns                  A JSON including both secretNftEvent & TEE enclave response (shards datas and description).
 */
const mintSecretNFT = (nftFile, nftMetadata, secretNftFile, secretNftMetadata, ipfsClient, ownerPair, clusterId = 0, royalty = 0, collectionId = undefined, isSoulbound = false, waitUntil = constants_1.WaitUntil.BlockInclusion) => __awaiter(void 0, void 0, void 0, function* () {
    // 0. query Enclave with /Health API
    yield (0, tee_1.getEnclaveHealthStatus)(clusterId);
    // 1. media encryption and upload
    const { privateKey, publicKey } = yield (0, encryption_1.generatePGPKeys)();
    const { Hash: offchainDataHash } = yield ipfsClient.storeNFT(nftFile, nftMetadata);
    const { Hash: secretOffchainDataHash } = yield (0, exports.secretNftEncryptAndUploadFile)(secretNftFile, publicKey, ipfsClient, secretNftMetadata);
    // 2. secret NFT minting
    const secretNftEvent = yield (0, nft_1.createSecretNft)(offchainDataHash, secretOffchainDataHash, royalty, collectionId, isSoulbound, ownerPair, waitUntil);
    // 3. request to format and store a batch of secret shares to the enclave
    const teeRes = yield (0, exports.prepareAndStoreKeyShares)(privateKey, ownerPair, secretNftEvent.nftId, "secret", undefined, clusterId);
    return {
        event: secretNftEvent,
        clusterResponse: teeRes,
    };
});
exports.mintSecretNFT = mintSecretNFT;
/**
 * @name viewSecretNFT
 * @summary                  Retrieves and decrypts the secret NFT hash.
 * @param nftId              The secret NFT id.
 * @param ipfsClient         A TernoaIPFS instance.
 * @param requester          Account of the secret NFT's owner(keyring) or address (string) or the decrypter account if NFT is delegated or rented.
 * @param requesterRole      Kind of the secret NFT's decrypter: it can be either "OWNER", "DELEGATEE" or "RENTEE"
 * @param extensionInjector  (Optional) The signer method retrived from your extension: object must have a signer key.
 * @param clusterId          (Optional)The TEE Cluster id. Default is set to cluster id 0.
 * @returns                  A string containing the secretNFT decrypted content.
 */
const viewSecretNFT = (nftId, ipfsClient, requester, requesterRole, extensionInjector, clusterId = 0) => __awaiter(void 0, void 0, void 0, function* () {
    // 0. query Enclave with /Health API
    yield (0, tee_1.getEnclaveHealthStatus)(clusterId);
    // 1. Get Secret NFT metadata hash
    const secretNftOffchainData = yield (0, nft_1.getSecretNftOffchainData)(nftId);
    const secretNftData = (yield ipfsClient.getFile(secretNftOffchainData));
    const encryptedSecretOffchainData = (yield ipfsClient.getFile(secretNftData.properties.encrypted_media.hash));
    // 2. Format and retrieve payload
    const lastBlockId = yield (0, crypto_1.getLastBlock)();
    const payload = yield (0, tee_1.formatRetrievePayload)(requester, requesterRole, nftId, lastBlockId, tee_1.SIGNER_BLOCK_VALIDITY, extensionInjector);
    const shares = yield (0, tee_1.teeKeySharesRetrieve)(clusterId, "secret", payload);
    // 3. Combine shares
    const privatePGPKey = (0, tee_1.combineKeyShares)(shares);
    // 4. Decrypt file to base 64
    const decryptedBase64 = yield (0, encryption_1.decryptFile)(encryptedSecretOffchainData, privatePGPKey);
    return decryptedBase64;
});
exports.viewSecretNFT = viewSecretNFT;
/**
 * @name mintCapsuleNFT
 * @summary                   Create a Capsule NFT and uploads your key's shards on a TEE.
 * @param owner               Account of the Capsule NFT's owner.
 * @param ipfsClient          A TernoaIPFS instance.
 * @param keys                Public and Private keys used to encrypt the file.
 * @param nftFile             File to upload as the preview of the Capsule NFT.
 * @param nftMetadata         The NFT preview metadata (Title, Description).
 * @param encryptedMedia      The array containing all the Capsule NFT encrypted media.
 * @param capsuleMetadata     (Optional) The Capusle NFT public metadata (Title, Description...).
 * @param clusterId           The TEE Cluster id. Default is 0
 * @param capsuleRoyalty      Percentage of all second sales that the capsule creator will receive. Default is 0%. It's a decimal number in range [0, 100].
 * @param capsuleCollectionId The collection to which the capsule NFT belongs. Optional Parameter: Default is undefined.
 * @param isSoulbound         If true, makes the Capsule intransferable. Default is false.
 * @param waitUntil           Execution trigger that can be set either to BlockInclusion or BlockFinalization. Default is BlockInclusion.
 * @returns                   A JSON including both capsuleEvent & TEE enclave response (shards datas and description).
 */
const mintCapsuleNFT = (ownerPair, ipfsClient, keys, nftFile, nftMetadata, encryptedMedia, capsuleMetadata, clusterId = 0, capsuleRoyalty = 0, capsuleCollectionId = undefined, isSoulbound = false, waitUntil = constants_1.WaitUntil.BlockInclusion) => __awaiter(void 0, void 0, void 0, function* () {
    // 0. query Enclave with /Health API
    yield (0, tee_1.getEnclaveHealthStatus)(clusterId);
    // 1. media encryption and upload
    const { Hash: offchainDataHash } = yield ipfsClient.storeNFT(nftFile, nftMetadata);
    const { Hash: capsuleOffchainDataHash } = yield ipfsClient.storeCapsuleNFT(keys.publicKey, encryptedMedia, capsuleMetadata);
    // 2. capsule NFT minting
    const capsuleEvent = yield (0, nft_1.createCapsule)(offchainDataHash, capsuleOffchainDataHash, capsuleRoyalty, capsuleCollectionId, isSoulbound, ownerPair, waitUntil);
    // 3. request to format and store a batch of secret shares to the enclave
    const teeRes = yield (0, exports.prepareAndStoreKeyShares)(keys.privateKey, ownerPair, capsuleEvent.nftId, "capsule", undefined, clusterId);
    return {
        event: capsuleEvent,
        clusterResponse: teeRes,
    };
});
exports.mintCapsuleNFT = mintCapsuleNFT;
/**
 * @name getCapsuleNFTPrivateKey
 * @summary                  Retrieves the capsule NFT private key to decrypt the secret hashes from properties.
 * @param nftId              The capsule NFT id.
 * @param requester          Account of the capsule NFT's owner (keyring) or address (string) or the decrypter account or address if NFT is delegated or rented.
 * @param requesterRole      Kind of the capsule NFT's decrypter: it can be either "OWNER", "DELEGATEE" or "RENTEE"
 * @param extensionInjector  (Optional) The signer method retrived from your extension: object must have a signer key.
 * @param clusterId          (Optional) The TEE Cluster id. Default is set to 0.
 * @returns                  A string containing the capsule NFT private key.
 */
const getCapsuleNFTPrivateKey = (nftId, requester, requesterRole, extensionInjector, clusterId = 0) => __awaiter(void 0, void 0, void 0, function* () {
    // 0. query Enclave with /Health API
    yield (0, tee_1.getEnclaveHealthStatus)(clusterId);
    // 1. Format and retrieve payload
    const lastBlockId = yield (0, crypto_1.getLastBlock)();
    const payload = yield (0, tee_1.formatRetrievePayload)(requester, requesterRole, nftId, lastBlockId, tee_1.SIGNER_BLOCK_VALIDITY, extensionInjector);
    const shares = yield (0, tee_1.teeKeySharesRetrieve)(clusterId, "capsule", payload);
    // 3. Combine Key
    return (0, tee_1.combineKeyShares)(shares);
});
exports.getCapsuleNFTPrivateKey = getCapsuleNFTPrivateKey;
