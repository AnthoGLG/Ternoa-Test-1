import { IKeyringPair } from "@polkadot/types/types";
import { File } from "formdata-node";
import { TernoaIPFS } from "./ipfs";
import { CapsuleMedia, MediaMetadataType, NftMetadataType, PGPKeysType, RequesterType } from "./types";
import { WaitUntil } from "../constants";
/**
 * @name secretNftEncryptAndUploadFile
 * @summary                 Encrypts and uploads a file on an IFPS gateway.
 * @param file              File to encrypt and then upload on IPFS.
 * @param publicPGPKey      Public Key to encrypt the file.
 * @param ipfsClient        A TernoaIPFS instance.
 * @param nftMetadata       Optional secret NFT metadata (Title, Description, (...)) {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-510-Secret-nft.md here}.
 * @param mediaMetadata     Optional asset NFT metadata (Name, Description, (...)) {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-510-Secret-nft.md here}.
 * @returns                 The data object with the secret NFT IPFS hash (ex: to add as offchain secret metadatas in the extrinsic).
 */
export declare const secretNftEncryptAndUploadFile: (file: File, publicPGPKey: string, ipfsClient: TernoaIPFS, nftMetadata?: Partial<NftMetadataType>, mediaMetadata?: MediaMetadataType) => Promise<import("./types").IpfsAddDataResponseType>;
/**
 * @name getTemporarySignerKeys
 * @summary                 Generates a temporary signer account with soft-derivation
 * @param address           The owner address
 * @param lastBlockId       The last chain block number: Use our asyncronous getLastBlock() helper.
 * @returns                 A temporary signing key pair.
 */
export declare const getTemporarySignerKeys: (address: string, lastBlockId: number) => Promise<import("@polkadot/keyring/types").KeyringPair>;
/**
 * @name prepareAndStoreKeyShares
 * @summary                  Splits the private key into shards, format and send them for upload on to a Tee Cluster.
 * @param privateKey         The private key to be splited with Shamir algorithm.
 * @param signer             Account owner of the private key to split (keyring) or address (string) .
 * @param nftId              The Capsule NFT id or Secret NFT id to link to the private key.
 * @param kind               The kind of nft linked to the key to upload: "secret" or "capsule".
 * @param extensionInjector  (Optional)The signer method retrived from your extension to sign the transaction. We recommand Polkadot extention: object must have a signer key.
 * @param clusterId          (Optional)The TEE Cluster id. Default is set to cluster id 0.
 * @returns                  The TEE enclave response (shards datas and description).
 */
export declare const prepareAndStoreKeyShares: (privateKey: string, signer: IKeyringPair | string, nftId: number, kind: "secret" | "capsule", extensionInjector?: Record<string, any>, clusterId?: number) => Promise<import("./types").TeeSharesStoreType[]>;
/**
 * @name mintSecretNFT
 * @summary                  Encrypts your data to create a secret NFT on-chain and uploads your key's shards on a TEE.
 * @param nftFile            File to upload as the preview of the encrypted NFT.
 * @param nftMetadata        NFT metadata (Title, Description).
 * @param secretNftFile      File to encrypt and then upload on IPFS.
 * @param secretNftMetadata  Secret NFT metadata (Title, Description).
 * @param ipfsClient         A TernoaIPFS instance.
 * @param ownerPair          Account of the secret NFT's owner.
 * @param clusterId          The TEE Cluster id. Default is set to cluster id 0.
 * @param royalty            Percentage of all second sales that the secret NFT creator will receive. Default is 0%. It's a decimal number in range [0, 100].
 * @param collectionId       The collection to which the secret NFT belongs. Optional Parameter: Default is undefined.
 * @param isSoulbound        If true, makes the secret NFT intransferable. Default is false.
 * @param waitUntil          Execution trigger that can be set either to BlockInclusion or BlockFinalization. Default is BlockInclusion.
 * @returns                  A JSON including both secretNftEvent & TEE enclave response (shards datas and description).
 */
export declare const mintSecretNFT: (nftFile: File, nftMetadata: NftMetadataType, secretNftFile: File, secretNftMetadata: NftMetadataType, ipfsClient: TernoaIPFS, ownerPair: IKeyringPair, clusterId?: number, royalty?: number, collectionId?: number | undefined, isSoulbound?: boolean, waitUntil?: WaitUntil) => Promise<{
    event: import("../nft").SecretNftData;
    clusterResponse: import("./types").TeeSharesStoreType[];
}>;
/**
 * @name viewSecretNFT
 * @summary                  Retrieves and decrypts the secret NFT hash.
 * @param nftId              The secret NFT id.
 * @param ipfsClient         A TernoaIPFS instance.
 * @param requester          Account of the secret NFT's owner(keyring) or address (string) or the decrypter account if NFT is delegated or rented.
 * @param requesterRole      Kind of the secret NFT's decrypter: it can be either "OWNER", "DELEGATEE" or "RENTEE"
 * @param extensionInjector  (Optional) The signer method retrived from your extension: object must have a signer key.
 * @param clusterId          (Optional)The TEE Cluster id. Default is set to cluster id 0.
 * @returns                  A string containing the secretNFT decrypted content.
 */
export declare const viewSecretNFT: (nftId: number, ipfsClient: TernoaIPFS, requester: IKeyringPair | string, requesterRole: RequesterType, extensionInjector?: Record<string, any>, clusterId?: number) => Promise<string>;
/**
 * @name mintCapsuleNFT
 * @summary                   Create a Capsule NFT and uploads your key's shards on a TEE.
 * @param owner               Account of the Capsule NFT's owner.
 * @param ipfsClient          A TernoaIPFS instance.
 * @param keys                Public and Private keys used to encrypt the file.
 * @param nftFile             File to upload as the preview of the Capsule NFT.
 * @param nftMetadata         The NFT preview metadata (Title, Description).
 * @param encryptedMedia      The array containing all the Capsule NFT encrypted media.
 * @param capsuleMetadata     (Optional) The Capusle NFT public metadata (Title, Description...).
 * @param clusterId           The TEE Cluster id. Default is 0
 * @param capsuleRoyalty      Percentage of all second sales that the capsule creator will receive. Default is 0%. It's a decimal number in range [0, 100].
 * @param capsuleCollectionId The collection to which the capsule NFT belongs. Optional Parameter: Default is undefined.
 * @param isSoulbound         If true, makes the Capsule intransferable. Default is false.
 * @param waitUntil           Execution trigger that can be set either to BlockInclusion or BlockFinalization. Default is BlockInclusion.
 * @returns                   A JSON including both capsuleEvent & TEE enclave response (shards datas and description).
 */
export declare const mintCapsuleNFT: (ownerPair: IKeyringPair, ipfsClient: TernoaIPFS, keys: PGPKeysType, nftFile: File, nftMetadata: NftMetadataType, encryptedMedia: CapsuleMedia[], capsuleMetadata?: Partial<NftMetadataType>, clusterId?: number, capsuleRoyalty?: number, capsuleCollectionId?: number | undefined, isSoulbound?: boolean, waitUntil?: WaitUntil) => Promise<{
    event: import("../nft").CapsuleNFTData<import("../nft").NftData>;
    clusterResponse: import("./types").TeeSharesStoreType[];
}>;
/**
 * @name getCapsuleNFTPrivateKey
 * @summary                  Retrieves the capsule NFT private key to decrypt the secret hashes from properties.
 * @param nftId              The capsule NFT id.
 * @param requester          Account of the capsule NFT's owner (keyring) or address (string) or the decrypter account or address if NFT is delegated or rented.
 * @param requesterRole      Kind of the capsule NFT's decrypter: it can be either "OWNER", "DELEGATEE" or "RENTEE"
 * @param extensionInjector  (Optional) The signer method retrived from your extension: object must have a signer key.
 * @param clusterId          (Optional) The TEE Cluster id. Default is set to 0.
 * @returns                  A string containing the capsule NFT private key.
 */
export declare const getCapsuleNFTPrivateKey: (nftId: number, requester: IKeyringPair | string, requesterRole: RequesterType, extensionInjector?: Record<string, any>, clusterId?: number) => Promise<string>;
