"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeoutTrigger = exports.ensureHttps = exports.retryPost = exports.removeURLSlash = exports.roundBalance = exports.formatPermill = exports.convertFileToBuffer = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const buffer_1 = require("buffer");
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
/**
 * @name convertFileToBuffer
 * @summary                 Converts a File to Buffer.
 * @param file              File to convert.
 * @returns                 A Buffer.
 */
const convertFileToBuffer = (file) => __awaiter(void 0, void 0, void 0, function* () {
    const arrayBuffer = yield file.arrayBuffer();
    const buffer = buffer_1.Buffer.from(arrayBuffer);
    return buffer;
});
exports.convertFileToBuffer = convertFileToBuffer;
/**
 * @name formatPermill
 * @summary         Checks that percent is in range 0 to 100 and format to permill.
 * @param percent   Number in range from 0 to 100 with max 4 decimals.
 * @returns         The formated percent in permill format.
 */
const formatPermill = (percent) => {
    if (percent > 100 || percent < 0) {
        throw new Error(constants_1.Errors.MUST_BE_PERCENTAGE);
    }
    return parseFloat(percent.toFixed(4)) * 10000;
};
exports.formatPermill = formatPermill;
const roundBalance = (amount) => Number((0, blockchain_1.balanceToNumber)(new bn_js_1.default(amount), { forceUnit: "-", withUnit: false }).split(",").join(""));
exports.roundBalance = roundBalance;
const removeURLSlash = (url) => {
    if (url.length === 0)
        return url;
    const lastChar = url.charAt(url.length - 1);
    if (lastChar === "/") {
        return url.slice(0, -1);
    }
    else {
        return url;
    }
};
exports.removeURLSlash = removeURLSlash;
const retryPost = (fn, n) => __awaiter(void 0, void 0, void 0, function* () {
    let lastError;
    for (let i = 0; i < n; i++) {
        try {
            return yield fn();
        }
        catch (err) {
            lastError = {
                isRetryError: true,
                status: "SDK_RETRY_POST_ERROR",
                message: (err === null || err === void 0 ? void 0 : err.message) ? err.message : JSON.stringify(err),
            };
        }
    }
    return lastError;
});
exports.retryPost = retryPost;
const ensureHttps = (url) => {
    if (!url)
        throw new Error(constants_1.Errors.URL_UNDEFINED);
    if (url.indexOf("https://") === 0)
        return url;
    else if (url.indexOf("http://") === 0)
        return url.replace("http://", "https://");
    else
        return "https://" + url;
};
exports.ensureHttps = ensureHttps;
const timeoutTrigger = (fn, duration = 10000) => {
    return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
            reject(new Error("Error: Function timed out"));
        }, duration);
        try {
            const data = fn();
            clearTimeout(timer);
            resolve(data);
        }
        catch (error) {
            clearTimeout(timer);
            reject(error);
        }
    });
};
exports.timeoutTrigger = timeoutTrigger;
