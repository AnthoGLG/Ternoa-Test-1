"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateMarketplaceMetadata = exports.validateCollectionMetadata = exports.validateOptionalNFTMetadata = exports.validateNFTMetadata = exports.TernoaIPFS = void 0;
const formdata_node_1 = require("formdata-node");
const form_data_encoder_1 = require("form-data-encoder");
const stream_1 = require("stream");
const constants_1 = require("../constants");
const http_1 = require("./http");
/**
 * @implements {IServiceIPFS}
 */
class TernoaIPFS {
    constructor(apiUrl = new URL("https://ipfs.ternoa.dev"), apiKey) {
        /**
         * Service API `URL`.
         * @readonly
         */
        this.apiUrl = apiUrl;
        /**
         * Authorization token.
         *
         * @readonly
         */
        this.apiKey = apiKey;
    }
    getFile(hash) {
        return _a.get(this, hash);
    }
    storeFile(file) {
        return _a.storeFile(this, file);
    }
    storeNFT(file, metadata) {
        return _a.storeNFT(this, file, metadata);
    }
    storeSecretNFT(encryptedFile, encryptedFileType, publicKey, nftMetadata, mediaMetadata) {
        return _a.storeSecretNFT(this, encryptedFile, encryptedFileType, publicKey, nftMetadata, mediaMetadata);
    }
    storeCapsuleNFT(publicKey, encryptedMedia, nftMetadata) {
        return _a.storeCapsuleNFT(this, publicKey, encryptedMedia, nftMetadata);
    }
    storeCollection(profileFile, bannerFile, metadata) {
        return _a.storeCollection(this, profileFile, bannerFile, metadata);
    }
    storeMarketplace(file, metadata) {
        return _a.storeMarketplace(this, file, metadata);
    }
}
exports.TernoaIPFS = TernoaIPFS;
_a = TernoaIPFS;
/**
 * Get file from IPFS.
 *
 * @param ternoaIpfsService
 * @param hash
 * @returns IPFS file
 */
TernoaIPFS.get = ({ apiUrl }, hash) => __awaiter(void 0, void 0, void 0, function* () {
    const httpClient = new http_1.HttpClient(apiUrl.toString());
    const endpoint = `/ipfs/${hash}`;
    return httpClient.get(endpoint);
});
/**
 * Upload file form data to IPFS.
 *
 * @param service
 * @param form
 * @returns IPFS data (hash, size, name)
 */
TernoaIPFS.upload = ({ apiKey, apiUrl }, form) => __awaiter(void 0, void 0, void 0, function* () {
    const httpClient = new http_1.HttpClient(apiUrl.toString());
    const endpoint = "/api/v0/add";
    let headers = Object.assign({}, (apiKey && { apiKey }));
    let data = form;
    if (typeof process === "object" &&
        typeof process.versions === "object" &&
        typeof process.versions.node !== "undefined") {
        const encoder = new form_data_encoder_1.FormDataEncoder(form);
        headers = Object.assign(Object.assign({}, headers), encoder.headers);
        data = stream_1.Readable.from(encoder);
    }
    return httpClient.post(endpoint, data, {
        maxContentLength: 100000000, // 100mb
        maxBodyLength: 1000000000, // 100mb
        headers,
    });
});
/**
 * Store a single file on IPFS.
 *
 * @param service
 * @param file
 * @returns IPFS data (hash, size, name)
 */
TernoaIPFS.storeFile = (service, file) => __awaiter(void 0, void 0, void 0, function* () {
    const form = new formdata_node_1.FormData();
    form.append("file", file);
    return yield _a.upload(service, form);
});
/**
 * Store a Ternoa basic NFT's metadata & asset on IPFS.
 *
 * @param service
 * @param file      NFT's asset
 * @param metadata  Ternoa basic NFT metadata structure {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-100-Basic-NFT.md#metadata here}.
 * @returns         IPFS data (Hash, Size, Name)
 */
TernoaIPFS.storeNFT = (service, file, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    var _b;
    (0, exports.validateNFTMetadata)(metadata);
    const res = yield _a.storeFile(service, file);
    if (!res)
        throw new Error(`${constants_1.Errors.IPFS_FILE_UPLOAD_ERROR} - Unable to upload NFT's asset`);
    const { Hash: hash, Size: size } = res;
    const nftMetadata = Object.assign(Object.assign({}, metadata), { image: hash, properties: Object.assign(Object.assign({}, metadata.properties), { media: Object.assign(Object.assign({}, (_b = metadata.properties) === null || _b === void 0 ? void 0 : _b.media), { hash,
                size, type: file.type, name: file.name }) }) });
    const metadataBlob = new formdata_node_1.Blob([JSON.stringify(nftMetadata)], { type: "application/json" });
    const metadataFile = new formdata_node_1.File([metadataBlob], "NFT metadata");
    return yield _a.storeFile(service, metadataFile);
});
/**
 * Store a Ternoa secret NFT's metadata & asset on IPFS.
 *
 * @param service
 * @param encryptedFile     NFT's encrypted asset.
 * @param encryptedFileType The original encrypted file type.
 * @param publicKey         Public key used to encrypt the Secret NFT.
 * @param nftMetadata       (Optional) Secret NFT metadata {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-520-Secret-nft.md here}.
 * @param mediaMetadata     (Optional) Secret NFT asset metadata.
 * @returns                 IPFS secret NFT data (Hash, Size, Name).
 */
TernoaIPFS.storeSecretNFT = (service, encryptedFile, encryptedFileType, publicKey, nftMetadata, mediaMetadata) => __awaiter(void 0, void 0, void 0, function* () {
    var _c, _d;
    if (nftMetadata)
        (0, exports.validateOptionalNFTMetadata)(nftMetadata);
    if (typeof publicKey !== "string")
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : Secret NFT's publicKey must be a string`);
    const publicKeyBlob = new formdata_node_1.Blob([publicKey], { type: "text/plain" });
    const publicKeyFile = new formdata_node_1.File([publicKeyBlob], "SecretNFT public key");
    const publicKeyRes = yield _a.storeFile(service, publicKeyFile);
    if (!publicKeyRes)
        throw new Error(`${constants_1.Errors.IPFS_FILE_UPLOAD_ERROR} - Unable to upload secret NFT's public key`);
    const nftPublicKeyHash = publicKeyRes.Hash;
    const blob = new formdata_node_1.Blob([encryptedFile], { type: "text/plain" });
    const file = new formdata_node_1.File([blob], "SecretNFT metadata");
    const secretNFTRes = yield _a.storeFile(service, file);
    if (!secretNFTRes)
        throw new Error(`${constants_1.Errors.IPFS_FILE_UPLOAD_ERROR} - Unable to upload secret NFT's asset`);
    const { Hash: secretNFTHash, Size: secretNFTSize } = secretNFTRes;
    const secretNFTMetadata = Object.assign(Object.assign({}, (nftMetadata && nftMetadata)), { properties: Object.assign(Object.assign({}, nftMetadata === null || nftMetadata === void 0 ? void 0 : nftMetadata.properties), { encrypted_media: Object.assign(Object.assign(Object.assign({}, (typeof ((_c = nftMetadata === null || nftMetadata === void 0 ? void 0 : nftMetadata.properties) === null || _c === void 0 ? void 0 : _c.encrypted_media) === "object" && ((_d = nftMetadata === null || nftMetadata === void 0 ? void 0 : nftMetadata.properties) === null || _d === void 0 ? void 0 : _d.encrypted_media))), { hash: secretNFTHash, type: encryptedFileType !== null && encryptedFileType !== void 0 ? encryptedFileType : file.type, size: secretNFTSize }), (mediaMetadata && mediaMetadata)), public_key_of_nft: nftPublicKeyHash }) });
    const secretNFTMetadataBlob = new formdata_node_1.Blob([JSON.stringify(secretNFTMetadata)], { type: "application/json" });
    const secretNFTMetadataFile = new formdata_node_1.File([secretNFTMetadataBlob], "secretNFT metadata");
    return yield _a.storeFile(service, secretNFTMetadataFile);
});
/**
 * Store a Ternoa Capsule NFT's metadata & assets on IPFS.
 *
 * @param service
 * @param publicKey         Public key used to encrypt the Capsule NFT.
 * @param encryptedMedia    An array of NFT's encrypted asset.
 * @param nftMetadata       (Optional) Capsule NFT metadata {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-530-Capsule.md here}.
 * @returns                 IPFS Capsule data (Hash, Size, Name).
 */
TernoaIPFS.storeCapsuleNFT = (service, publicKey, encryptedMedia, nftMetadata) => __awaiter(void 0, void 0, void 0, function* () {
    if (nftMetadata)
        (0, exports.validateOptionalNFTMetadata)(nftMetadata);
    if (typeof publicKey !== "string")
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : Capsule NFT's publicKey must be a string`);
    const publicKeyBlob = new formdata_node_1.Blob([publicKey], { type: "text/plain" });
    const publicKeyFile = new formdata_node_1.File([publicKeyBlob], "SecretNFT public key");
    const publicKeyRes = yield _a.storeFile(service, publicKeyFile);
    if (!publicKeyRes)
        throw new Error(`${constants_1.Errors.IPFS_FILE_UPLOAD_ERROR} - Unable to upload secret NFT's public key`);
    const nftPublicKeyHash = publicKeyRes.Hash;
    const capsuleMedia = [];
    yield Promise.all(encryptedMedia.map((_e) => __awaiter(void 0, void 0, void 0, function* () {
        var { encryptedFile, type } = _e, rest = __rest(_e, ["encryptedFile", "type"]);
        const blob = new formdata_node_1.Blob([encryptedFile], { type: "text/plain" });
        const file = new formdata_node_1.File([blob], "capsuleMediaNFT");
        const { Hash: mediaHash, Size: mediaSize } = yield _a.storeFile(service, file);
        if (!mediaHash)
            throw new Error(`${constants_1.Errors.IPFS_FILE_UPLOAD_ERROR} - Unable to upload capsule NFT's media`);
        const media = Object.assign({ hash: mediaHash, type: type, size: Number(mediaSize) }, rest);
        capsuleMedia.push(media);
    })));
    const capsuleMetadata = Object.assign(Object.assign({}, (nftMetadata && nftMetadata)), { properties: Object.assign(Object.assign({}, nftMetadata === null || nftMetadata === void 0 ? void 0 : nftMetadata.properties), { encrypted_media: capsuleMedia, public_key_of_nft: nftPublicKeyHash }) });
    const capsuleNFTMetadataBlob = new formdata_node_1.Blob([JSON.stringify(capsuleMetadata)], { type: "application/json" });
    const capsuleNFTMetadataFile = new formdata_node_1.File([capsuleNFTMetadataBlob], "capsuleNFT metadata");
    return yield _a.storeFile(service, capsuleNFTMetadataFile);
});
/**
 * Store a single Ternoa Collection's metadata & assets on IPFS.
 *
 * @param service
 * @param profileFile   Collection's profile asset
 * @param bannerFile    Collection's banner asset
 * @param metadata      Ternoa Collection metadata structure {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-101-Collection.md#metadata here}.
 * @returns             IPFS data (Hash, Size, Name)
 */
TernoaIPFS.storeCollection = (service, profileFile, bannerFile, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    (0, exports.validateCollectionMetadata)(metadata);
    const profileRes = yield _a.storeFile(service, profileFile);
    if (!profileRes)
        throw new Error(`${constants_1.Errors.IPFS_FILE_UPLOAD_ERROR} - Unable to upload collection's profile asset`);
    const bannerRes = yield _a.storeFile(service, bannerFile);
    if (!bannerRes)
        throw new Error(`${constants_1.Errors.IPFS_FILE_UPLOAD_ERROR} - Unable to upload collection's banner asset`);
    const collectionMetadata = Object.assign(Object.assign({}, metadata), { profile_image: profileRes.Hash, banner_image: bannerRes.Hash });
    const metadataBlob = new formdata_node_1.Blob([JSON.stringify(collectionMetadata)], { type: "application/json" });
    const metadataFile = new formdata_node_1.File([metadataBlob], "Collection metadata");
    return yield _a.storeFile(service, metadataFile);
});
/**
 * Store a single Ternoa Marketplace's metadata & asset on IPFS.
 *
 * @param service
 * @param file      Marketplace's logo asset
 * @param metadata  Ternoa Marketplace metadata structure {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-200-Marketplace.md#metadata here}.
 * @returns         IPFS data (Hash, Size, Name)
 */
TernoaIPFS.storeMarketplace = (service, file, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    (0, exports.validateMarketplaceMetadata)(metadata);
    const res = yield _a.storeFile(service, file);
    if (!res)
        throw new Error(`${constants_1.Errors.IPFS_FILE_UPLOAD_ERROR} - Unable to upload marketplace's logo asset`);
    const collectionMetadata = Object.assign(Object.assign({}, metadata), { logo: res.Hash });
    const metadataBlob = new formdata_node_1.Blob([JSON.stringify(collectionMetadata)], { type: "application/json" });
    const metadataFile = new formdata_node_1.File([metadataBlob], "Collection metadata");
    return yield _a.storeFile(service, metadataFile);
});
const validateNFTMetadata = ({ title, description }) => {
    if (!title)
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : NFT's title is required`);
    else if (typeof title !== "string") {
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : NFT's title must be a string`);
    }
    if (!description)
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : NFT's description is required`);
    else if (typeof description !== "string") {
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : NFT's description must be a string`);
    }
};
exports.validateNFTMetadata = validateNFTMetadata;
const validateOptionalNFTMetadata = ({ title, description }) => {
    if (title !== undefined && typeof title !== "string") {
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : Secret NFT's title must be a string`);
    }
    if (description !== undefined && typeof description !== "string") {
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : Secret NFT's description must be a string`);
    }
};
exports.validateOptionalNFTMetadata = validateOptionalNFTMetadata;
const validateCollectionMetadata = ({ name, description }) => {
    if (!name)
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : Collection's name is required`);
    else if (typeof name !== "string") {
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : Collection's name must be a string`);
    }
    if (!name)
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : Collection's description is required`);
    else if (typeof description !== "string") {
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : Collection's description must be a string`);
    }
};
exports.validateCollectionMetadata = validateCollectionMetadata;
const validateMarketplaceMetadata = ({ name }) => {
    if (!name)
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : Marketplace's name is required`);
    else if (typeof name !== "string") {
        throw new TypeError(`${constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR} : Marketplace's name must be a string`);
    }
};
exports.validateMarketplaceMetadata = validateMarketplaceMetadata;
