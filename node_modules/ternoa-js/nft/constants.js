"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCollectionOffchainDataLimit = exports.getNftOffchainDataLimit = exports.getCollectionSizeLimit = exports.getInitialSecretMintFee = exports.getInitialMintFee = void 0;
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
/**
 * @name getInitialMintFee
 * @summary Original mint fee.
 * @returns Original NFT mint fee.
 */
const getInitialMintFee = () => __awaiter(void 0, void 0, void 0, function* () {
    const fee = (0, blockchain_1.consts)(constants_1.txPallets.nft, constants_1.chainConstants.initialMintFee);
    return fee;
});
exports.getInitialMintFee = getInitialMintFee;
/**
 * @name getInitialSecretMintFee
 * @summary Original secret mint fee.
 * @returns Original Secret NFT mint fee.
 */
const getInitialSecretMintFee = () => __awaiter(void 0, void 0, void 0, function* () {
    const fee = (0, blockchain_1.consts)(constants_1.txPallets.nft, constants_1.chainConstants.initialSecretMintFee);
    return fee;
});
exports.getInitialSecretMintFee = getInitialSecretMintFee;
/**
 * @name getCollectionSizeLimit
 * @summary Maximum collection length.
 * @returns Number.
 */
const getCollectionSizeLimit = () => __awaiter(void 0, void 0, void 0, function* () {
    const limit = (0, blockchain_1.consts)(constants_1.txPallets.nft, constants_1.chainConstants.collectionSizeLimit);
    return limit.toNumber();
});
exports.getCollectionSizeLimit = getCollectionSizeLimit;
/**
 * @name getNftOffchainDataLimit
 * @summary Provides the maximum offchain data length.
 * @returns Number.
 */
const getNftOffchainDataLimit = () => __awaiter(void 0, void 0, void 0, function* () {
    const limit = (0, blockchain_1.consts)(constants_1.txPallets.nft, constants_1.chainConstants.nftOffchainDataLimit);
    return limit.toNumber();
});
exports.getNftOffchainDataLimit = getNftOffchainDataLimit;
/**
 * @name getCollectionOffchainDataLimit
 * @summary Provides the maximum offchain data length.
 * @returns Number.
 */
const getCollectionOffchainDataLimit = () => __awaiter(void 0, void 0, void 0, function* () {
    const limit = (0, blockchain_1.consts)(constants_1.txPallets.nft, constants_1.chainConstants.collectionOffchainDataLimit);
    return limit.toNumber();
});
exports.getCollectionOffchainDataLimit = getCollectionOffchainDataLimit;
