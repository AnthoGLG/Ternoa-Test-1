"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setCollectionOffchaindata = exports.setCollectionOffchaindataTx = exports.burnCollection = exports.burnCollectionTx = exports.closeCollection = exports.closeCollectionTx = exports.limitCollection = exports.limitCollectionTx = exports.createCollection = exports.createCollectionTx = exports.notifyEnclaveKeyUpdate = exports.notifyEnclaveKeyUpdateTx = exports.setCapsuleOffchaindata = exports.setCapsuleOffchaindataTx = exports.createCapsule = exports.createCapsuleTx = exports.convertNftToCapsule = exports.convertNftToCapsuleTx = exports.addNftToCollection = exports.addNftToCollectionTx = exports.transferNft = exports.transferNftTx = exports.setRoyalty = exports.setRoyaltyTx = exports.delegateNft = exports.delegateNftTx = exports.burnNft = exports.burnNftTx = exports.addSecretToNft = exports.addSecretToNftTx = exports.createSecretNft = exports.createSecretNftTx = exports.createNft = exports.createNftTx = void 0;
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
const events_1 = require("../events");
const utils_1 = require("../helpers/utils");
// NFTs
/**
 * @name createNftTx
 * @summary             Creates an unsigned unsubmitted Create-NFT Transaction Hash.
 * @param offchainData  Off-chain related NFT metadata. Can be an IPFS Hash, an URL or plain text.
 * @param royalty       Percentage of all second sales that the creator will receive. It's a decimal number in range [0, 100]. Default is 0.
 * @param collectionId  The collection that this NFT will belong. Optional Parameter.
 * @param isSoulbound   If true makes the NFT untransferable. Default is false.
 * @returns             Unsigned unsubmitted Create-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
const createNftTx = (offchainData, royalty = 0, collectionId = undefined, isSoulbound = false) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedRoyality = (0, utils_1.formatPermill)(royalty);
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.createNft, [
        offchainData,
        formattedRoyality,
        collectionId,
        isSoulbound,
    ]);
});
exports.createNftTx = createNftTx;
/**
 * @name createNft
 * @summary             Creates an NFT on the chain.
 * @param offchainData  Off-chain related NFT metadata. Can be an IPFS Hash, an URL or plain text.
 * @param royalty       Percentage of all second sales that the creator will receive. It's a decimal number in range [0, 100]. Default is 0.
 * @param collectionId  The collection that this NFT will belong. Optional Parameter.
 * @param isSoulbound   If true makes the NFT untransferable. Default is false.
 * @param keyring       Account that will sign the transaction.
 * @param waitUntil     Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns             NFTCreatedEvent Blockchain event.
 */
const createNft = (offchainData, royalty = 0, collectionId = undefined, isSoulbound = false, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.createNftTx)(offchainData, royalty, collectionId, isSoulbound);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.NFTCreatedEvent);
});
exports.createNft = createNft;
/**
 * @name createSecretNftTx
 * @summary                   Creates an unsigned unsubmitted Create-Secret-NFT Transaction Hash.
 * @param offchainData        Off-chain related NFT preview metadata. Can be an IPFS hash, a URL or plain text.
 * @param secretOffchainData  Off-chain related NFT secret metadata. Can be an IPFS hash, a URL or plain text.
 * @param royalty             Percentage of all second sales that the creator will receive. It's a decimal number in range [0, 100]. Default is 0.
 * @param collectionId        The collection to which the NFT belongs. Optional Parameter.
 * @param isSoulbound         If true, makes the NFT intransferable. Default is false.
 * @returns                   Unsigned unsubmitted Create-Secret-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
const createSecretNftTx = (offchainData, secretOffchainData, royalty = 0, collectionId = undefined, isSoulbound = false) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedRoyality = (0, utils_1.formatPermill)(royalty);
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.createSecretNft, [
        offchainData,
        secretOffchainData,
        formattedRoyality,
        collectionId,
        isSoulbound,
    ]);
});
exports.createSecretNftTx = createSecretNftTx;
/**
 * @name createSecretNft
 * @summary                   Creates a Secret NFT on chain.
 * @param offchainData        Off-chain related NFT preview metadata. Can be an IPFS hash, a URL or plain text.
 * @param secretOffchainData  Off-chain related NFT secret metadata. Can be an IPFS hash, a URL or plain text.
 * @param royalty             Percentage of all second sales that the creator will receive. It's a decimal number in range [0, 100]. Default is 0.
 * @param collectionId        The collection to which the NFT belongs. Optional Parameter.
 * @param isSoulbound         If true, makes the NFT intransferable. Default is false.
 * @param keyring             Account that will sign the transaction.
 * @param waitUntil           Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns                   Secret NFT data combining the data from NFTCreatedEvent and SecretAddedToNFTEvent.
 */
const createSecretNft = (offchainData, secretOffchainData, royalty = 0, collectionId = undefined, isSoulbound = false, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.createSecretNftTx)(offchainData, secretOffchainData, royalty, collectionId, isSoulbound);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    const nftCreatedEvent = events.findEventOrThrow(events_1.NFTCreatedEvent);
    const secretAddedToNFTEvent = events.findEventOrThrow(events_1.SecretAddedToNFTEvent);
    return {
        nftId: nftCreatedEvent.nftId,
        owner: nftCreatedEvent.owner,
        creator: nftCreatedEvent.owner,
        offchainData: nftCreatedEvent.offchainData,
        secretOffchainData: secretAddedToNFTEvent.offchainData,
        royalty: nftCreatedEvent.royalty,
        collectionId: nftCreatedEvent.collectionId,
        isSoulbound: nftCreatedEvent.isSoulbound,
    };
});
exports.createSecretNft = createSecretNft;
/**
 * @name addSecretToNftTx
 * @summary                   Creates an unsigned unsubmitted Add-Secret-NFT Transaction Hash.
 * @param id                  The ID of the NFT.
 * @param secretOffchainData  Off-chain related NFT secret metadata. Can be an IPFS hash, a URL or plain text.
 * @returns                   Unsigned unsubmitted Create-Secret-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
const addSecretToNftTx = (id, secretOffchainData) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.addSecret, [id, secretOffchainData]);
});
exports.addSecretToNftTx = addSecretToNftTx;
/**
 * @name addSecretToNft
 * @summary                   Adds a Secret to an NFT on chain.
 * @param id                  The ID of the NFT.
 * @param secretOffchainData  Off-chain related NFT secret metadata. Can be an IPFS hash, a URL or plain text.
 * @param keyring             Account that will sign the transaction.
 * @param waitUntil           Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns                   SecretAddedToNFTEvent Blockchain event.
 */
const addSecretToNft = (id, secretOffchainData, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.addSecretToNftTx)(id, secretOffchainData);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.SecretAddedToNFTEvent);
});
exports.addSecretToNft = addSecretToNft;
/**
 * @name burnNftTx
 * @summary   Creates an unsigned unsubmitted Burn-NFT Transaction Hash.
 * @param id  The ID of the NFT.
 * @returns   Unsigned unsubmitted Burn-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
const burnNftTx = (id) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.burnNft, [id]);
});
exports.burnNftTx = burnNftTx;
/**
 * @name burnNft
 * @summary           Burns an NFT from the chain.
 * @param id          The ID of the NFT.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           NFTBurnedEvent Blockchain event.
 */
const burnNft = (id, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.burnNftTx)(id);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.NFTBurnedEvent);
});
exports.burnNft = burnNft;
/**
 * @name delegateNftTx
 * @summary           Creates an unsigned unsubmitted Delegate-NFT Transaction Hash.
 * @param id          The ID of the NFT.
 * @param recipient   Destination account. If set to undefined this functions acts as a way to undelegate a delegated NFT.
 * @returns           Unsigned unsubmitted Delegate-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
const delegateNftTx = (id, recipient = undefined) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.delegateNft, [id, recipient]);
});
exports.delegateNftTx = delegateNftTx;
/**
 * @name delegateNft
 * @summary           Delegates an NFT to someone.
 * @param id          The ID of the NFT.
 * @param recipient   Destination account. If set to undefined this functions acts as a way to undelegate a delegated NFT.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           NFTDelegatedEvent Blockchain event.
 */
const delegateNft = (id, recipient = undefined, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.delegateNftTx)(id, recipient);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.NFTDelegatedEvent);
});
exports.delegateNft = delegateNft;
/**
 * @name setRoyaltyTx
 * @summary       Creates an unsigned unsubmitted Set-Royalty Transaction Hash.
 * @param id      The ID of the NFT.
 * @param amount  The new royalty value.
 * @returns       Unsigned unsubmitted Set-Royalty-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
const setRoyaltyTx = (id, amount) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedRoyality = (0, utils_1.formatPermill)(amount);
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.setRoyalty, [id, formattedRoyality]);
});
exports.setRoyaltyTx = setRoyaltyTx;
/**
 * @name setRoyalty
 * @summary           Sets the royalty of an NFT.
 * @param id          The ID of the NFT.
 * @param amount      The new royalty value.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           NFTRoyaltySetEvent Blockchain event.
 */
const setRoyalty = (id, amount, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.setRoyaltyTx)(id, amount);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.NFTRoyaltySetEvent);
});
exports.setRoyalty = setRoyalty;
/**
 * @name transferNftTx
 * @summary           Creates an unsigned unsubmitted Transfer-NFT Transaction Hash.
 * @param id          The ID of the NFT.
 * @param recipient   Destination account.
 * @returns           Unsigned unsubmitted Transfer-NFT Transaction Hash. The Hash is only valid for 5 minutes
 */
const transferNftTx = (id, recipient) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.transferNft, [id, recipient]);
});
exports.transferNftTx = transferNftTx;
/**
 * @name transferNft
 * @summary           Sends an NFT to someone.
 * @param id          The ID of the NFT.
 * @param recipient   Destination account.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           NFTTransferredEvent Blockchain event.
 */
const transferNft = (id, recipient, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.transferNftTx)(id, recipient);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.NFTTransferredEvent);
});
exports.transferNft = transferNft;
/**
 * @name addNftToCollectionTx
 * @summary               Creates an unsigned unsubmitted Add-NFT-To-Collection Transaction Hash.
 * @param nftId           The ID of the NFT.
 * @param collectionId    The ID of the Collection.
 * @returns               Unsigned unsubmitted Add-NFT-To-Collection Transaction Hash. The Hash is only valid for 5 minutes.
 */
const addNftToCollectionTx = (nftId, collectionId) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.addNftToCollection, [nftId, collectionId]);
});
exports.addNftToCollectionTx = addNftToCollectionTx;
/**
 * @name addNftToCollection
 * @summary               Adds an NFT to an existing collection.
 * @param nftId           The ID of the NFT.
 * @param collectionId    The ID of the Collection.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               NFTAddedToCollectionEvent Blockchain event.
 */
const addNftToCollection = (nftId, collectionId, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.addNftToCollectionTx)(nftId, collectionId);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.NFTAddedToCollectionEvent);
});
exports.addNftToCollection = addNftToCollection;
// Capsule
/**
 * @name convertNftToCapsuleTx
 * @summary    		              Creates an unsigned unsubmitted Convert-To-Capsule Transaction Hash for a Capsule NFT.
 * @param nftId		              The NFT Id to convert into a capsule.
 * @param capsuleOffchainData 	The offchain capsule data (a string)
 * @returns  		                Unsigned unsubmitted Convert-To-Capsule Transaction Hash. The Hash is only valid for 5 minutes.
 */
const convertNftToCapsuleTx = (nftId, capsuleOffchainData) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.convertToCapsule, [nftId, capsuleOffchainData]);
});
exports.convertNftToCapsuleTx = convertNftToCapsuleTx;
/**
 * @name convertNftToCapsule
 * @summary    		              Convert an existing basic NFT into a Capsule NFT.
 * @param nftId		              The NFT Id to convert in a capsule.
 * @param capsuleOffchainData 	The offchain capsule data (a string)
 * @param keyring               Account that will sign the transaction.
 * @param waitUntil             Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		                NFTConvertedToCapsuleEvent Blockchain event.
 */
const convertNftToCapsule = (nftId, capsuleOffchainData, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.convertNftToCapsuleTx)(nftId, capsuleOffchainData);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.NFTConvertedToCapsuleEvent);
});
exports.convertNftToCapsule = convertNftToCapsule;
/**
 * @name createCapsuleTx
 * @summary    		             Creates an unsigned unsubmitted Create-Capsule Transaction Hash for a Capsule NFT.
 * @param offchainData         Off-chain data related to the NFT metadata. Can be an IPFS Hash, an URL or plain text.
 * @param capsuleOffchainData  Off-chain data related to the Capsule metadata. Can be an IPFS hash, a URL or plain text.
 * @param royalty              Percentage of all second sales that the creator will receive. It's a decimal number in range [0, 100]. Default is 0.
 * @param collectionId         The collection to which the NFT belongs. Optional Parameter.
 * @param isSoulbound          If true, makes the Capsule intransferable. Default is false.
 * @returns  		               Unsigned unsubmitted Create-Capsule Transaction Hash. The Hash is only valid for 5 minutes.
 */
const createCapsuleTx = (offchainData, capsuleOffchainData, royalty = 0, collectionId = undefined, isSoulbound = false) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedRoyality = (0, utils_1.formatPermill)(royalty);
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.createCapsule, [
        offchainData,
        capsuleOffchainData,
        formattedRoyality,
        collectionId,
        isSoulbound,
    ]);
});
exports.createCapsuleTx = createCapsuleTx;
/**
 * @name createCapsule
 * @summary    		              Convert an existing basic NFT into a Capsule NFT.
 * @param offchainData          Off-chain data related to the NFT metadata. Can be an IPFS Hash, an URL or plain text.
 * @param capsuleOffchainData   Off-chain data related to the Capsule metadata. Can be an IPFS hash, a URL or plain text.
 * @param royalty               Percentage of all second sales that the creator will receive. It's a decimal number in range [0, 100]. Default is 0.
 * @param collectionId          The collection to which the NFT belongs. Optional Parameter.
 * @param isSoulbound           If true, makes the Capsule intransferable. Default is false.
 * @param keyring               Account that will sign the transaction.
 * @param waitUntil             Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		                Capsule NFT data combining the data from NFTCreatedEvent and NFTConvertedToCapsuleEvent.
 */
const createCapsule = (offchainData, capsuleOffchainData, royalty = 0, collectionId = undefined, isSoulbound = false, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.createCapsuleTx)(offchainData, capsuleOffchainData, royalty, collectionId, isSoulbound);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    const nftCreatedEvent = events.findEventOrThrow(events_1.NFTCreatedEvent);
    const nftConvertedToCapsuleEvent = events.findEventOrThrow(events_1.NFTConvertedToCapsuleEvent);
    return {
        nftId: nftCreatedEvent.nftId,
        owner: nftCreatedEvent.owner,
        creator: nftCreatedEvent.owner,
        offchainData: nftCreatedEvent.offchainData,
        capsuleOffchainData: nftConvertedToCapsuleEvent.offchainData,
        royalty: nftCreatedEvent.royalty,
        collectionId: nftCreatedEvent.collectionId,
        isSoulbound: nftCreatedEvent.isSoulbound,
    };
});
exports.createCapsule = createCapsule;
// /**
//  * @name revertCapsuleTx
//  * @summary    		    Creates an unsigned unsubmitted Revert-Capsule Transaction Hash for a Capsule NFT.
//  * @param nftId		    The NFT Id to remove the capsule part.
//  * @returns  		      Unsigned unsubmitted Revert-Capsule Transaction Hash. The Hash is only valid for 5 minutes.
//  */
// export const revertCapsuleTx = async (nftId: number): Promise<TransactionHashType> => {
//   return await createTxHex(txPallets.nft, txActions.revertCapsule, [nftId])
// }
// /**
//  * @name revertCapsule
//  * @summary		       Removes the capsule part of an NFT.
//  * @param nftId		   The NFT Id to remove the capsule part.
//  * @param keyring		 Account that will sign the transaction.
//  * @param waitUntil  Execution trigger that can be set either to BlockInclusion or BlockFinalization.
//  * @returns  		     CapsuleRevertedEvent Blockchain event.
//  */
// export const revertCapsule = async (
//   nftId: number,
//   keyring: IKeyringPair,
//   waitUntil: WaitUntil,
// ): Promise<CapsuleRevertedEvent> => {
//   const tx = await revertCapsuleTx(nftId)
//   const { events } = await submitTxBlocking(tx, waitUntil, keyring)
//   return events.findEventOrThrow(CapsuleRevertedEvent)
// }
/**
 * @name setCapsuleOffchaindataTx
 * @summary    		              Creates an unsigned unsubmitted Set-Capsule-Offchain-Data Transaction Hash for a Capsule NFT.
 * @param nftId		              The NFT Id to set the capsule's offchain data. Capsules are mutable
 * @param capsuleOffchainData 	The offchain capsule data (a string)
 * @returns  		                Unsigned unsubmitted Set-Capsule-Offchain-Data Transaction Hash. The Hash is only valid for 5 minutes.
 */
const setCapsuleOffchaindataTx = (nftId, capsuleOffchainData) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.setCapsuleOffchaindata, [nftId, capsuleOffchainData]);
});
exports.setCapsuleOffchaindataTx = setCapsuleOffchaindataTx;
/**
 * @name setCapsuleOffchaindata
 * @summary    		               Sets the offchain data of a Capsule NFT.
 * @param nftId		               The NFT Id to set the capsule's offchain data. Capsules are mutable
 * @param capsuleOffchainData 	 The offchain capsule data (a string)
 * @param keyring                Account that will sign the transaction.
 * @param waitUntil              Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		                 CapsuleOffchainDataSetEvent Blockchain event.
 */
const setCapsuleOffchaindata = (nftId, capsuleOffchainData, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.setCapsuleOffchaindataTx)(nftId, capsuleOffchainData);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.CapsuleOffchainDataSetEvent);
});
exports.setCapsuleOffchaindata = setCapsuleOffchaindata;
/**
 * @name notifyEnclaveKeyUpdateTx
 * @summary    		   Creates an unsigned unsubmitted Notify-Enclave-Key-Update Transaction Hash for a Capsule NFT.
 * @param nftId		   The capsule NFT Id to signify that new keys were requested by the capsule owner.
 * @returns  		     Unsigned unsubmitted Notify-Enclave-Key-Update Transaction Hash. The Hash is only valid for 5 minutes.
 */
const notifyEnclaveKeyUpdateTx = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.notifyEnclaveKeyUpdate, [nftId]);
});
exports.notifyEnclaveKeyUpdateTx = notifyEnclaveKeyUpdateTx;
/**
 * @name notifyEnclaveKeyUpdate
 * @summary		       Notifies the enclave that capsule owner requests new keys.
 * @param nftId		   The capsule NFT Id to signify that new keys were requested by the capsule owner.
 * @param keyring		 Account that will sign the transaction.
 * @param waitUntil  Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		     CapsuleKeyUpdateNotifiedEvent Blockchain event.
 */
const notifyEnclaveKeyUpdate = (nftId, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.notifyEnclaveKeyUpdateTx)(nftId);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.CapsuleKeyUpdateNotifiedEvent);
});
exports.notifyEnclaveKeyUpdate = notifyEnclaveKeyUpdate;
// Collections
/**
 * @name createCollectionTx
 * @summary               Creates an unsigned unsubmitted Create-Collection Transaction Hash.
 * @param offchainData    Off-chain related Collection metadata. Can be an IPFS Hash, an URL or plain text.
 * @param limit           The maximum amount that NFTs that the collection can hold. This is optional
 * @returns               Unsigned unsubmitted Create-Collection Transaction Hash. The Hash is only valid for 5 minutes.
 */
const createCollectionTx = (offchainData, limit = undefined) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.createCollection, [offchainData, limit]);
});
exports.createCollectionTx = createCollectionTx;
/**
 * @name createCollection
 * @summary               Creates a collection.
 * @param offchainData    Off-chain related Collection metadata. Can be an IPFS Hash, an URL or plain text.
 * @param limit           Amount of NFTs that can be associated with this collection. This is optional
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               CollectionCreatedEvent Blockchain event.
 */
const createCollection = (offchainData, limit = undefined, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.createCollectionTx)(offchainData, limit);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.CollectionCreatedEvent);
});
exports.createCollection = createCollection;
/**
 * @name limitCollectionTx
 * @summary       Creates an unsigned unsubmitted Limit-Collection Transaction Hash.
 * @param id      The ID of the Collection.
 * @param limit   Amount of NFTs that can be associated with this collection.
 * @returns       Unsigned unsubmitted Limit-Collection Transaction Hash. The Hash is only valid for 5 minutes.
 */
const limitCollectionTx = (id, limit) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.limitCollection, [id, limit]);
});
exports.limitCollectionTx = limitCollectionTx;
/**
 * @name limitCollection
 * @summary           Limits how many NFTs can be associated with this collection.
 * @param id          The ID of the Collection.
 * @param limit       Amount of NFTs that can be associated with this collection.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           CollectionLimitedEvent Blockchain event.
 */
const limitCollection = (id, limit, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.limitCollectionTx)(id, limit);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.CollectionLimitedEvent);
});
exports.limitCollection = limitCollection;
/**
 * @name closeCollectionTx
 * @summary   Creates an unsigned unsubmitted Close-Collection Transaction Hash.
 * @param id  The ID of the Collection.
 * @returns   Unsigned unsubmitted Close-Collection Transaction Hash. The Hash is only valid for 5 minutes.
 */
const closeCollectionTx = (id) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.closeCollection, [id]);
});
exports.closeCollectionTx = closeCollectionTx;
/**
 * @name closeCollection
 * @summary           Closes the collection so that no new NFTs can be added.
 * @param id          The ID of the Collection.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           CollectionClosedEvent Blockchain event.
 */
const closeCollection = (id, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.closeCollectionTx)(id);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.CollectionClosedEvent);
});
exports.closeCollection = closeCollection;
/**
 * @name burnCollectionTx
 * @summary   Creates an unsigned unsubmitted Burn-Collection Transaction Hash.
 * @param id  The ID of the Collection.
 * @returns   Unsigned unsubmitted Burn-Collection Transaction Hash. The Hash is only valid for 5 minutes.
 */
const burnCollectionTx = (id) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.burnCollection, [id]);
});
exports.burnCollectionTx = burnCollectionTx;
/**
 * @name burnCollection
 * @summary           Burns an existing collection. The collections needs to be empty before it can be burned.
 * @param id          The ID of the Collection.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           CollectionBurnedEvent Blockchain event.
 */
const burnCollection = (id, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.burnCollectionTx)(id);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.CollectionBurnedEvent);
});
exports.burnCollection = burnCollection;
/**
 * @name setCollectionOffchaindataTx
 * @summary    		              Creates an unsigned unsubmitted Set-Collection-Offchain-Data Transaction Hash for a Collection.
 * @param id		                The ID of the Collection.
 * @param offchainData 	        The offchain collection data (a string)
 * @returns  		                Unsigned unsubmitted Set-Collection-Offchain-Data Transaction Hash. The Hash is only valid for 5 minutes.
 */
const setCollectionOffchaindataTx = (id, offchainData) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.setCollectionOffchaindata, [id, offchainData]);
});
exports.setCollectionOffchaindataTx = setCollectionOffchaindataTx;
/**
 * @name setCollectionOffchaindata
 * @summary    		               Sets the offchain data of a Collection.
 * @param id		                 The ID of the Collection.
 * @param offchainData 	         The offchain collection data (a string)
 * @param keyring                Account that will sign the transaction.
 * @param waitUntil              Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		                 CollectionOffchainDataSetEvent Blockchain event.
 */
const setCollectionOffchaindata = (id, offchainData, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.setCollectionOffchaindataTx)(id, offchainData);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.CollectionOffchainDataSetEvent);
});
exports.setCollectionOffchaindata = setCollectionOffchaindata;
