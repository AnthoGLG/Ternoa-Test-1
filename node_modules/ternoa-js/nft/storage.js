"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCollectionData = exports.getNftData = exports.getNextCollectionId = exports.getNextNftId = exports.getCapsuleOffchainData = exports.getSecretNftOffchainData = exports.getCapsuleMintFee = exports.getSecretNftMintFee = exports.getNftMintFee = void 0;
const util_1 = require("@polkadot/util");
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
/**
 * @name nftMintFee
 * @summary Fee to mint an NFT (extra fee on top of the tx fees).
 * @returns NFT mint fee.
 */
const getNftMintFee = () => __awaiter(void 0, void 0, void 0, function* () {
    const fee = yield (0, blockchain_1.query)(constants_1.txPallets.nft, constants_1.chainQuery.nftMintFee);
    return fee;
});
exports.getNftMintFee = getNftMintFee;
/**
 * @name getSecretNftMintFee
 * @summary Fee to mint a secret NFT (extra fee on top of the tx fees and basic nft).
 * @returns Secret NFT mint fee.
 */
const getSecretNftMintFee = () => __awaiter(void 0, void 0, void 0, function* () {
    const fee = yield (0, blockchain_1.query)(constants_1.txPallets.nft, constants_1.chainQuery.secretNftMintFee);
    return fee;
});
exports.getSecretNftMintFee = getSecretNftMintFee;
/**
 * @name getCapsuleMintFee
 * @summary Fee to mint a Capsule. (extra fee on top of the tx fees).
 * @returns Capsule NFT mint fee.
 */
const getCapsuleMintFee = () => __awaiter(void 0, void 0, void 0, function* () {
    const fee = yield (0, blockchain_1.query)(constants_1.txPallets.nft, constants_1.chainQuery.capsuleMintFee);
    return fee;
});
exports.getCapsuleMintFee = getCapsuleMintFee;
/**
 * @name getSecretNftOffchainData
 * @summary Get the secret offchain data of a Secret NFT.
 * @returns Secret NFT secret offchain data.
 */
const getSecretNftOffchainData = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    const secretOffchainData = yield (0, blockchain_1.query)(constants_1.txPallets.nft, constants_1.chainQuery.secretNftsOffchainData, [nftId]);
    return secretOffchainData.toHuman();
});
exports.getSecretNftOffchainData = getSecretNftOffchainData;
/**
 * @name getCapsuleOffchainData
 * @summary Get the capsule offchain data.
 * @returns The capsule offchain data.
 */
const getCapsuleOffchainData = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    const capsuleOffchainData = yield (0, blockchain_1.query)(constants_1.txPallets.nft, constants_1.chainQuery.capsuleOffchainData, [nftId]);
    return capsuleOffchainData.toHuman();
});
exports.getCapsuleOffchainData = getCapsuleOffchainData;
/**
 * @name getNextNftId
 * @summary Get the next NFT Id available.
 * @returns Number.
 */
const getNextNftId = () => __awaiter(void 0, void 0, void 0, function* () {
    const id = yield (0, blockchain_1.query)(constants_1.txPallets.nft, constants_1.chainQuery.nextNFTId);
    return id.toNumber();
});
exports.getNextNftId = getNextNftId;
/**
 * @name getNextCollectionId
 * @summary Get the next collection Id available.
 * @returns Number.
 */
const getNextCollectionId = () => __awaiter(void 0, void 0, void 0, function* () {
    const id = yield (0, blockchain_1.query)(constants_1.txPallets.nft, constants_1.chainQuery.nextCollectionId);
    return id.toNumber();
});
exports.getNextCollectionId = getNextCollectionId;
/**
 * @name getNftData
 * @summary       Provides the data related to one NFT.
 * @param nftId   The NFT id.
 * @returns       A JSON object with the NFT data. ex:{owner, creator, offchainData, (...)}
 */
const getNftData = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    const data = yield (0, blockchain_1.query)(constants_1.txPallets.nft, constants_1.chainQuery.nfts, [nftId]);
    if (data.isEmpty == true) {
        return null;
    }
    try {
        const result = data.toJSON();
        // The offchainData is an hexadecimal string, we convert it to a human readable string.
        if (result.offchainData)
            result.offchainData = (0, util_1.hexToString)(result.offchainData);
        return result;
    }
    catch (error) {
        throw new Error(`${constants_1.Errors.NFT_CONVERSION_ERROR}`);
    }
});
exports.getNftData = getNftData;
/**
 * @name getCollectionData
 * @summary             Provides the data related to one NFT collection. ex:{owner, creator, offchainData, limit, isClosed(...)}
 * @param collectionId  The collection id.
 * @returns             A JSON object with data of a single NFT collection.
 */
const getCollectionData = (collectionId) => __awaiter(void 0, void 0, void 0, function* () {
    const data = yield (0, blockchain_1.query)(constants_1.txPallets.nft, constants_1.chainQuery.collections, [collectionId]);
    if (data.isEmpty == true) {
        return null;
    }
    try {
        return data.toJSON();
    }
    catch (error) {
        throw new Error(`${constants_1.Errors.COLLECTION_CONVERSION_ERROR}`);
    }
});
exports.getCollectionData = getCollectionData;
