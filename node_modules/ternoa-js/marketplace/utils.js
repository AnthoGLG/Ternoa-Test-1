"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatMarketplaceCollectionList = exports.formatMarketplaceOffchainData = exports.formatMarketplaceAccountList = exports.formatMarketplaceFee = exports.convertMarketplaceFee = void 0;
const utils_1 = require("../helpers/utils");
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
const enum_1 = require("./enum");
/**
 * @name convertMarketplaceFee
 * @summary         Checks the type fee and format it accordingly. Numbers are formatted into BN. Percentages are formatted in Permill.
 * @param fee       The fee to format : It can only be an CommissionFeeType or ListingFeeType.
 * @returns         The formatted fee.
 */
const convertMarketplaceFee = (fee) => __awaiter(void 0, void 0, void 0, function* () {
    if (typeof fee === "object") {
        if (typeof fee.set.flat === "number") {
            const flatFee = (0, blockchain_1.numberToBalance)(fee.set.flat);
            fee.set.flat = flatFee;
        }
        if (fee.set.percentage) {
            const percentageFee = (0, utils_1.formatPermill)(fee.set.percentage);
            fee.set.percentage = percentageFee;
        }
    }
    return fee;
});
exports.convertMarketplaceFee = convertMarketplaceFee;
/**
 * @name formatMarketplaceFee
 * @summary Returns an object representing either the marketplace commission or listing fee in either in Flat or Percentage format.
 *
 * @param action - The type of Action. Can be either "Noop" (No Operation: to keep it as it is), "Remove" or "set".
 * @param feeType - The type of fee. Can be either "percentage" or "flat",
 * @param value - The value of the fee. If type is 'Percentage' value refers to a decimal number in range [0, 100]. If type is 'Flat' value refers to a balance amount in a number. Default is 0.
 *
 * @returns An object representing either the marketplace commission or listing fee.
 */
const formatMarketplaceFee = (action, feeType, value) => {
    if (action !== "Noop" && action !== "Remove" && action !== "set")
        throw new Error("INCORRECT_ACTION: action has to be either 'Noop', 'Remove', 'set'.");
    if (feeType && feeType !== "percentage" && feeType !== "flat")
        throw new Error("INCORRECT_FEE_TYPE: feeType has to be either 'percentage' or 'flat'.");
    switch (action) {
        case "Noop":
            return enum_1.MarketplaceConfigAction.Noop;
        case "Remove":
            return enum_1.MarketplaceConfigAction.Remove;
        case "set": {
            if (value === undefined || feeType === undefined)
                throw new Error(`${constants_1.Errors.VALUE_MUST_BE_DEFINED}`);
            if (feeType && feeType === "percentage") {
                return {
                    [enum_1.MarketplaceConfigAction.Set]: { [enum_1.MarketplaceConfigFeeType.Percentage]: (0, utils_1.formatPermill)(value) },
                };
            }
            else {
                return {
                    [enum_1.MarketplaceConfigAction.Set]: { [enum_1.MarketplaceConfigFeeType.Flat]: (0, blockchain_1.numberToBalance)(value) },
                };
            }
        }
        default:
            return enum_1.MarketplaceConfigAction.Noop;
    }
};
exports.formatMarketplaceFee = formatMarketplaceFee;
/**
 * @name formatMarketplaceAccountList
 * @summary Returns an object representing a list of accounts : if the marketplace kind is private, it allows these accounts to sell NFT. If the marketplace kind is public, it bans these accounts from selling NFT.
 *
 * @param action - The type of Action. Can be either "Noop" (No Operation: to keep it as it is), "Remove" or "set".
 * @param value - An array of addresses (string) to add to the list.
 *
 * @returns An object representing either the whitelisted or banned accounts.
 */
const formatMarketplaceAccountList = (action, value) => {
    if (action !== "Noop" && action !== "Remove" && action !== "set")
        throw new Error("INCORRECT_ACTION: action has to be either 'Noop', 'Remove', 'set'.");
    switch (action) {
        case "Noop":
            return enum_1.MarketplaceConfigAction.Noop;
        case "Remove":
            return enum_1.MarketplaceConfigAction.Remove;
        case "set": {
            if (value === undefined)
                throw new Error(`${constants_1.Errors.VALUE_MUST_BE_DEFINED}`);
            return {
                [enum_1.MarketplaceConfigAction.Set]: value,
            };
        }
        default:
            return enum_1.MarketplaceConfigAction.Noop;
    }
};
exports.formatMarketplaceAccountList = formatMarketplaceAccountList;
/**
 * @name formatMarketplaceOffchainData
 * @summary Returns the off-chain related marketplace metadata. Can be an IPFS Hash, an URL or plain text.
 *
 * @param action - The type of Action. Can be either "Noop" (No Operation: to keep it as it is), "Remove" or "set".
 * @param value - The marketplkace offchain metadata : a string
 *
 * @returns An object representing either the marketplace offchain metadata.
 */
const formatMarketplaceOffchainData = (action, value) => {
    if (action !== "Noop" && action !== "Remove" && action !== "set")
        throw new Error("INCORRECT_ACTION: action has to be either 'Noop', 'Remove', 'set'.");
    switch (action) {
        case "Noop":
            return enum_1.MarketplaceConfigAction.Noop;
        case "Remove":
            return enum_1.MarketplaceConfigAction.Remove;
        case "set": {
            if (value === undefined)
                throw new Error(`${constants_1.Errors.VALUE_MUST_BE_DEFINED}`);
            return {
                [enum_1.MarketplaceConfigAction.Set]: value,
            };
        }
        default:
            return enum_1.MarketplaceConfigAction.Noop;
    }
};
exports.formatMarketplaceOffchainData = formatMarketplaceOffchainData;
/**
 * @name formatMarketplaceCollectionList
 * @summary Returns an object representing a list of collection of NFT : if the marketplace kind is private, it allows these collection to be listed. If the marketplace kind is public, it bans these collection of NFT from listing.
 *
 * @param action - The type of Action. Can be either "Noop" (No Operation: to keep it as it is), "Remove" or "set".
 * @param value - An array of Collection id (number) to add to the list.
 *
 * @returns An object representing either the whitelisted or banned collection Id.
 */
const formatMarketplaceCollectionList = (action, value) => {
    if (action !== "Noop" && action !== "Remove" && action !== "set")
        throw new Error("INCORRECT_ACTION: action has to be either 'Noop', 'Remove', 'set'.");
    switch (action) {
        case "Noop":
            return enum_1.MarketplaceConfigAction.Noop;
        case "Remove":
            return enum_1.MarketplaceConfigAction.Remove;
        case "set": {
            if (value === undefined)
                throw new Error(`${constants_1.Errors.VALUE_MUST_BE_DEFINED}`);
            return {
                [enum_1.MarketplaceConfigAction.Set]: value,
            };
        }
        default:
            return enum_1.MarketplaceConfigAction.Noop;
    }
};
exports.formatMarketplaceCollectionList = formatMarketplaceCollectionList;
