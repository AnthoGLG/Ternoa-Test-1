"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setMarketplaceMintFee = exports.setMarketplaceMintFeeTx = exports.buyNft = exports.buyNftTx = exports.unlistNft = exports.unlistNftTx = exports.listNft = exports.listNftTx = exports.setMarketplaceKind = exports.setMarketplaceKindTx = exports.setMarketplaceOwner = exports.setMarketplaceOwnerTx = exports.setMarketplaceConfiguration = exports.setMarketplaceConfigurationTx = exports.createMarketplace = exports.createMarketplaceTx = void 0;
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
const events_1 = require("../events");
const enum_1 = require("./enum");
/**
 * @name createMarketplaceTx
 * @summary               Creates an unsigned unsubmitted Create-Marketplace Transaction Hash.
 * @param kind            Kind of marketplace : It must be public or private.
 * @returns               Unsigned unsubmitted Create-Marketplace Transaction Hash. The Hash is only valid for 5 minutes.
 */
const createMarketplaceTx = (kind) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.createMarketplace, [kind]);
});
exports.createMarketplaceTx = createMarketplaceTx;
/**
 * @name createMarketplace
 * @summary               Creates a Marketplace on the chain.
 * @param kind            Kind of marketplace : It must be public or private.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               MarketplaceCreatedEvent Blockchain event.
 */
const createMarketplace = (kind, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.createMarketplaceTx)(kind);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.MarketplaceCreatedEvent);
});
exports.createMarketplace = createMarketplace;
/**
 * @name setMarketplaceConfigurationTx
 * @summary               Creates an unsigned unsubmitted Set-Marketplace-Configuration Transaction Hash.
 *
 *                        Each of the parameters of the marketplace, need one of the following type: Noop is set by default for each of the parameters.
 *                        - Noop: No Operation, nothing change.
 *                        - Remove: Current datas will be deleted.
 *                        - Set: An object that updates parameter value below.
 *                            - Commission Fee and Listing Fee require a data type (flat or percentage) under format : { [MarketplaceConfigAction.Set]: { setFeeType: number || BN}}
 *                            - AccountList require an array of string: { [MarketplaceConfigAction.Set]: string[]}
 *                            - OffChainData require a string: { [MarketplaceConfigAction.Set]: string}
 *                            - CollectionList require an arry of number: { [MarketplaceConfigAction.Set]: number[]}
 *
 *                        IMPORTANT: In order to avoid any error, we strongly recommand you to construct those fields using the helpers we provide.
 *                        - formatMarketplaceFee() for both commission and listing fee.
 *                        - formatMarketplaceAccountList() for the account list.
 *                        - formatMarketplaceOffchainData() for the offchain data.
 *                        - formatMarketplaceCollectionList() for the collection list.
 *                        - Check {@link https://docs.ternoa.network/for-developers/guides/marketplace/ Ternoa Doc}.
 *
 * @param id              Marketplace Id of the marketplace to update.
 * @param commissionFee   Commission when an NFT is sold on the marketplace : it can be set as flat (in Big Number format) or as percentage (in permill format). Without using formatters, you can use the convertMarketplaceFee() function.
 * @param listingFee      Fee when an NFT is added for sale to marketplace : it can be set as flat (in Big Number format) or as percentage (in permill format). Without using formatters, you can use the convertMarketplaceFee() function.
 * @param accountList     A list of accounts : if the marketplace kind is private, it allows these accounts to sell NFT. If the marketplace kind is public, it bans these accounts from selling NFT.
 * @param offchainData    Off-chain related marketplace metadata. Can be an IPFS Hash, an URL or plain text.
 * @param collectionList  A list of Collection Id: same as accountList, if the marketplace kind is private, the list is a whitelist and if the marketplace is public, the list bans the collection to be listed.
 * @returns               MarketplaceConfigSetEvent Blockchain event.
 */
const setMarketplaceConfigurationTx = (id, commissionFee = enum_1.MarketplaceConfigAction.Noop, listingFee = enum_1.MarketplaceConfigAction.Noop, accountList = enum_1.MarketplaceConfigAction.Noop, offchainData = enum_1.MarketplaceConfigAction.Noop, collectionList = enum_1.MarketplaceConfigAction.Noop) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.setMarketplaceConfiguration, [
        id,
        commissionFee,
        listingFee,
        accountList,
        offchainData,
        collectionList,
    ]);
});
exports.setMarketplaceConfigurationTx = setMarketplaceConfigurationTx;
/**
 * @name setMarketplaceConfiguration
 * @summary               Set or Remove (Noop for No Operation) the marketplace parameters configuration : Commission fee, listing fee, the account list or any offchain datas.
 *
 *                        Each of the parameters of the marketplace, need one of the following type: Noop is set by default for each of the parameters.
 *                        - Noop: No Operation, nothing change.
 *                        - Remove: Current datas will be deleted.
 *                        - Set: An object that updates parameter value below.
 *                            - Commission Fee and Listing Fee require a data type (flat or percentage) under format : { [MarketplaceConfigAction.Set]: { setFeeType: number || BN}}
 *                            - AccountList require an array of string: { [MarketplaceConfigAction.Set]: string[]}
 *                            - OffChainData require a string: { [MarketplaceConfigAction.Set]: string}
 *                            - CollectionList require an arry of number: { [MarketplaceConfigAction.Set]: number[]}
 *
 *                        IMPORTANT: In order to avoid any error, we strongly recommand you to construct those fields using the helpers we provide.
 *                        - formatMarketplaceFee() for both commission and listing fee.
 *                        - formatMarketplaceAccountList() for the account list.
 *                        - formatMarketplaceOffchainData() for the offchain data.
 *                        - formatMarketplaceCollectionList() for the collection list.
 *                        - Check {@link https://docs.ternoa.network/for-developers/guides/marketplace/ Ternoa Doc}.
 *
 * @param id              Marketplace Id of the marketplace to update.
 * @param commissionFee   Commission when an NFT is sold on the marketplace : it can be set as flat (in Big Number format) or as percentage (in permill format). Without using formatters, you can use the convertMarketplaceFee() function.
 * @param listingFee      Fee when an NFT is added for sale to marketplace : it can be set as flat (in Big Number format) or as percentage (in permill format). Without using formatters, you can use the convertMarketplaceFee() function.
 * @param accountList     A list of accounts : if the marketplace kind is private, it allows these accounts to sell NFT. If the marketplace kind is public, it bans these accounts from selling NFT.
 * @param offchainData    Off-chain related marketplace metadata. Can be an IPFS Hash, an URL or plain text.
 * @param collectionList  A list of Collection Id: same as accountList, if the marketplace kind is private, the list is a whitelist and if the marketplace is public, the list bans the collection to be listed.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               MarketplaceConfigSetEvent Blockchain event.
 */
const setMarketplaceConfiguration = (id, commissionFee = enum_1.MarketplaceConfigAction.Noop, listingFee = enum_1.MarketplaceConfigAction.Noop, accountList = enum_1.MarketplaceConfigAction.Noop, offchainData = enum_1.MarketplaceConfigAction.Noop, collectionList = enum_1.MarketplaceConfigAction.Noop, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.setMarketplaceConfigurationTx)(id, commissionFee, listingFee, accountList, offchainData, collectionList);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.MarketplaceConfigSetEvent);
});
exports.setMarketplaceConfiguration = setMarketplaceConfiguration;
/**
 * @name setMarketplaceOwnerTx
 * @summary               Creates an unsigned unsubmitted Set-Marketplace-Owner Transaction Hash.
 * @param id              Marketplace Id of the marketplace to be transferred.
 * @param recipient       Adress of the new marketplace owner.
 * @returns               Unsigned unsubmitted Set-Marketplace-Owner Transaction Hash. The Hash is only valid for 5 minutes.
 */
const setMarketplaceOwnerTx = (id, recipient) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.setMarketplaceOwner, [id, recipient]);
});
exports.setMarketplaceOwnerTx = setMarketplaceOwnerTx;
/**
 * @name setMarketplaceOwner
 * @summary               Set the new marketplace owner on the chain.
 * @param id              Marketplace Id of the marketplace to be transferred.
 * @param recipient       Address of the new marketplace owner.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               MarketplaceOwnerSetEvent Blockchain event.
 */
const setMarketplaceOwner = (id, recipient, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.setMarketplaceOwnerTx)(id, recipient);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.MarketplaceOwnerSetEvent);
});
exports.setMarketplaceOwner = setMarketplaceOwner;
/**
 * @name setMarketplaceKindTx
 * @summary               Creates an unsigned unsubmitted Set-Marketplace-Kind Transaction Hash.
 * @param kind            Kind of marketplace : It must be public or private.
 * @returns               Unsigned unsubmitted Set-Marketplace-Kind Transaction Hash. The Hash is only valid for 5 minutes.
 */
const setMarketplaceKindTx = (id, kind) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.setMarketplaceKind, [id, kind]);
});
exports.setMarketplaceKindTx = setMarketplaceKindTx;
/**
 * @name setMarketplaceKind
 * @summary               Set the new marketplace kind on the chain.
 * @param kind            Kind of marketplace : It must be public or private.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               MarketplaceKindSetEvent Blockchain event.
 */
const setMarketplaceKind = (id, kind, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.setMarketplaceKindTx)(id, kind);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.MarketplaceKindSetEvent);
});
exports.setMarketplaceKind = setMarketplaceKind;
/**
 * @name listNftTx
 * @summary               Creates an unsigned unsubmitted List-NFT Transaction Hash.
 * @param nftId           NFT Id of the NFT to be listed for sale.
 * @param marketplaceId   Marketplace Id of the marketplace to list the NFT on.
 * @param price           Price of the NFT.
 * @returns               Unsigned unsubmitted List-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
const listNftTx = (nftId, marketplaceId, price) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedPrice = typeof price === "number" ? (0, blockchain_1.numberToBalance)(price) : price;
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.listNft, [nftId, marketplaceId, formattedPrice]);
});
exports.listNftTx = listNftTx;
/**
 * @name listNft
 * @summary               Lists an NFT on a marketplace.
 * @param nftId           NFT Id of the NFT to be listed for sale.
 * @param marketplaceId   Marketplace Id of the marketplace to list the NFT on.
 * @param price           Price of the NFT.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               NFTListedEvent Blockchain event.
 */
const listNft = (nftId, marketplaceId, price, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.listNftTx)(nftId, marketplaceId, price);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.NFTListedEvent);
});
exports.listNft = listNft;
/**
 * @name unlistNftTx
 * @summary               Creates an unsigned unsubmitted Unlist-NFT Transaction Hash.
 * @param nftId           NFT Id of the NFT to be unlisted from sale.
 * @returns               Unsigned unsubmitted Unlist-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
const unlistNftTx = (nftId) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.unlistNft, [nftId]);
});
exports.unlistNftTx = unlistNftTx;
/**
 * @name unlistNft
 * @summary               Unlists an NFT from a marketplace.
 * @param nftId           NFT Id of the NFT to be unlisted from sale.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               NFTUnlistedEvent Blockchain event.
 */
const unlistNft = (nftId, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.unlistNftTx)(nftId);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.NFTUnlistedEvent);
});
exports.unlistNft = unlistNft;
/**
 * @name buyNftTx
 * @summary               Creates an unsigned unsubmitted Buy-NFT Transaction Hash.
 * @param nftId           NFT Id of the NFT for sale.
 * @param nftBuyingPrice  The NFT buying price signed.
 * @returns               Unsigned unsubmitted Buy-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
const buyNftTx = (nftId, nftBuyingPrice) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedNftBuyingPrice = typeof nftBuyingPrice === "number" ? (0, blockchain_1.numberToBalance)(nftBuyingPrice) : nftBuyingPrice;
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.buyNft, [nftId, formattedNftBuyingPrice]);
});
exports.buyNftTx = buyNftTx;
/**
 * @name buyNft
 * @summary               Buys an NFT on a marketplace.
 * @param nftId           NFT Id of the NFT for sale.
 * @param nftBuyingPrice  The NFT buying price signed.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               NFTSoldEvent Blockchain event.
 */
const buyNft = (nftId, nftBuyingPrice, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.buyNftTx)(nftId, nftBuyingPrice);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.NFTSoldEvent);
});
exports.buyNft = buyNft;
/**
 * @name setMarketplaceMintFeeTx
 * @summary               Creates an unsigned unsubmitted Set-Marketplace-Mint-Fee Transaction Hash.
 * @param fee             Fee to mint a marketplace.
 * @returns               Unsigned unsubmitted Set-Marketplace-Mint-Fee Transaction Hash. The Hash is only valid for 5 minutes.
 */
const setMarketplaceMintFeeTx = (fee) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedPrice = typeof fee === "number" ? (0, blockchain_1.numberToBalance)(fee) : fee;
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.setMarketplaceMintFee, [formattedPrice]);
});
exports.setMarketplaceMintFeeTx = setMarketplaceMintFeeTx;
/**
 * @name setMarketplaceMintFee
 * @summary               Set the new marketplace minting fee on the chain.
 * @param fee             Fee to mint a marketplace.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               NFTSoldEvent Blockchain event.
 */
const setMarketplaceMintFee = (fee, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.setMarketplaceMintFeeTx)(fee);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.MarketplaceMintFeeSetEvent);
});
exports.setMarketplaceMintFee = setMarketplaceMintFee;
