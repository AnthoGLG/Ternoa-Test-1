"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.balancesTransferKeepAlive = exports.balancesTransferKeepAliveTx = exports.balancesTransferAll = exports.balancesTransferAllTx = exports.balancesTransfer = exports.balancesTransferTx = void 0;
const blockchain_1 = require("../blockchain");
const constants_1 = require("../constants");
const events_1 = require("../events");
/**
 * @name balancesTransferTx
 * @summary             Creates an unsigned unsubmitted Balance-Transfert Transaction Hash.
 * @param to            Public address of the account to transfer the amount to.
 * @param amount        Token amount to transfer.
 * @returns             Unsigned unsubmitted Balance-Transfert Transaction Hash. The Hash is only valid for 5 minutes.
 */
const balancesTransferTx = (to, amount) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedAmount = typeof amount === "number" ? (0, blockchain_1.numberToBalance)(amount) : amount;
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.balances, constants_1.txActions.transfer, [to, formattedAmount]);
});
exports.balancesTransferTx = balancesTransferTx;
/**
 * @name balancesTransfer
 * @summary             Transfers some liquid free balance to another account.
 * @param to            Public address of the account to transfer the amount to.
 * @param amount        Token amount to transfer.
 * @param keyring       Account that will sign the transaction.
 * @param waitUntil     Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns             BalancesTransferEvent Blockchain event.
 */
const balancesTransfer = (to, amount, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.balancesTransferTx)(to, amount);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.BalancesTransferEvent);
});
exports.balancesTransfer = balancesTransfer;
/**
 * @name balancesTransferAllTx
 * @summary             Creates an unsigned unsubmitted Balance-TransfertAll Transaction Hash.
 * @param to            Public address of the account to transfer the amount to.
 * @param keepAlive     Ensure that the transfer does not kill the account, it retains the Existential Deposit.
 * @returns             Unsigned unsubmitted Balance-TransfertAll Transaction Hash. The Hash is only valid for 5 minutes.
 */
const balancesTransferAllTx = (to, keepAlive = true) => __awaiter(void 0, void 0, void 0, function* () {
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.balances, constants_1.txActions.transferAll, [to, keepAlive]);
});
exports.balancesTransferAllTx = balancesTransferAllTx;
/**
 * @name balancesTransferAll
 * @summary             Transfers the entire transferable balance from the caller account.
 * @param to            Public address of the account to transfer the amount to.
 * @param keepAlive     Ensure that the transfer does not kill the account, it retains the Existential Deposit.
 * @param keyring       Account that will sign the transaction.
 * @param waitUntil     Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns             BalancesTransferEvent Blockchain event.
 */
const balancesTransferAll = (to, keepAlive = true, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.balancesTransferAllTx)(to, keepAlive);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.BalancesTransferEvent);
});
exports.balancesTransferAll = balancesTransferAll;
/**
 * @name balancesTransferKeepAliveTx
 * @summary             Creates an unsigned unsubmitted Balance-TransfertKeepAlive Transaction Hash.
 * @param to            Public address of the account to transfer the amount to.
 * @param amount        Token amount to transfer.
 * @returns             Unsigned unsubmitted Balance-TransfertKeepAlive Transaction Hash. The Hash is only valid for 5 minutes.
 */
const balancesTransferKeepAliveTx = (to, amount) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedAmount = typeof amount === "number" ? (0, blockchain_1.numberToBalance)(amount) : amount;
    return yield (0, blockchain_1.createTxHex)(constants_1.txPallets.balances, constants_1.txActions.transferKeepAlive, [to, formattedAmount]);
});
exports.balancesTransferKeepAliveTx = balancesTransferKeepAliveTx;
/**
 * @name balancesTransferKeepAlive
 * @summary             Transfers some liquid free balance to another account with a check that the transfer will not kill the origin account.
 * @param to            Public address of the account to transfer the amount to.
 * @param amount        Token amount to transfer.
 * @param keyring       Account that will sign the transaction.
 * @param waitUntil     Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns             BalancesTransferEvent Blockchain event.
 */
const balancesTransferKeepAlive = (to, amount, keyring, waitUntil) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = yield (0, exports.balancesTransferKeepAliveTx)(to, amount);
    const { events } = yield (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring);
    return events.findEventOrThrow(events_1.BalancesTransferEvent);
});
exports.balancesTransferKeepAlive = balancesTransferKeepAlive;
