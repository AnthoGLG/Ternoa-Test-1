"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkBalanceForTransfer = exports.getTransferrableBalance = exports.getTotalBalance = exports.getBalances = void 0;
const constants_1 = require("../constants");
const blockchain_1 = require("../blockchain");
/**
 * @name getBalances
 * @summary             Get the balances of an account including free & reserved balances as well as the total.
 * Currently Mainnet also returns miscFrozen & feeFrozen while alphanet returns frozen and flags. After next Mainnet runtime upgrade both miscFrozen & feeFrozen will be removed.
 * @param address       Public address of the account to get balances.
 * @returns             The balances of the account.
 */
const getBalances = (address) => __awaiter(void 0, void 0, void 0, function* () {
    const balances = (yield (0, blockchain_1.query)(constants_1.txPallets.system, constants_1.chainQuery.account, [address])).data;
    return balances;
});
exports.getBalances = getBalances;
/**
 * @name getTotalBalance
 * @summary             Get the total balance of an account (free & reserve balances)
 * @param address       Public address of the account to get total balance for.
 * @returns             The total balance of an account (free & reserve balances)
 */
const getTotalBalance = (address) => __awaiter(void 0, void 0, void 0, function* () {
    const { free, reserved } = yield (0, exports.getBalances)(address);
    return free.add(reserved);
});
exports.getTotalBalance = getTotalBalance;
/**
 * @name getTransferrableBalance
 * @summary             Get the transferrable balance of an account.
 * @param address       Public address of the account to get transferrable balance for.
 * @returns             The transferrable balance of an account.
 */
const getTransferrableBalance = (address) => __awaiter(void 0, void 0, void 0, function* () {
    const { free, miscFrozen, feeFrozen, frozen } = yield (0, exports.getBalances)(address);
    let totalFrozen;
    if (miscFrozen !== undefined && feeFrozen !== undefined) {
        if (feeFrozen.gt(miscFrozen)) {
            totalFrozen = feeFrozen;
        }
        else {
            totalFrozen = miscFrozen;
        }
        return free.sub(totalFrozen);
    }
    else if (frozen) {
        return free.sub(frozen);
    }
    return free;
});
exports.getTransferrableBalance = getTransferrableBalance;
/**
 * @name checkBalanceForTransfer
 * @summary             Check if an account as enough funds to ensure a transfer.
 * @param address       Public address of the account to check balance for transfer.
 * @param value         Token amount to check before transfer.
 */
const checkBalanceForTransfer = (address, value) => __awaiter(void 0, void 0, void 0, function* () {
    const amount = typeof value === "number" ? (0, blockchain_1.numberToBalance)(value) : value;
    const { free } = yield (0, exports.getBalances)(address);
    return free.gt(amount);
});
exports.checkBalanceForTransfer = checkBalanceForTransfer;
